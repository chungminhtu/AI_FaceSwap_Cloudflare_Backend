<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=375, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Face Swap AI</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lexend+Deca:wght@300;400;500;600;700&display=swap');

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --bg-tertiary: #f1f5f9;
            --accent: #8b5cf6;
            --accent-hover: #7c3aed;
            --accent-secondary: #a78bfa;
            --accent-strong: #6d28d9;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --text-muted: #94a3b8;
            --border: #e2e8f0;
            --danger: #ef4444;
            --success: #10b981;
            --shadow-soft: 0 4px 20px rgba(15, 23, 42, 0.08);
            --shadow-md: 0 8px 30px rgba(15, 23, 42, 0.12);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
            touch-action: pan-y pan-x;
            -ms-touch-action: pan-y pan-x;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            transform: scale(1);
            transform-origin: top left;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
        }

        body {
            font-family: 'Lexend Deca', -apple-system, sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #ffffff 50%, #f1f5f9 100%);
            color: var(--text-primary);
            line-height: 1.5;
            font-size: 14px;
            -webkit-font-smoothing: antialiased;
            display: flex;
            flex-direction: column;
        }

        body.locked { overflow: hidden; }
        body.locked .main-container { filter: blur(14px); pointer-events: none; user-select: none; }

        /* Access Gate */
        .access-gate {
            position: fixed; inset: 0; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top, rgba(15, 11, 46, 0.85), rgba(10, 7, 30, 0.92));
            backdrop-filter: blur(18px);
            transition: opacity 0.3s, visibility 0.3s;
        }
        .access-gate.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        .gate-card {
            width: min(420px, 90vw); padding: 32px; border-radius: 12px;
            background: linear-gradient(145deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
            border: 1px solid rgba(255,255,255,0.18);
            box-shadow: 0 25px 60px rgba(18, 0, 56, 0.45);
            backdrop-filter: blur(26px);
            display: flex; flex-direction: column; gap: 18px; text-align: center;
        }
        .gate-title { font-size: 14px; font-weight: 700; letter-spacing: 1.2px; color: #fff; }
        .gate-subtitle { font-size: 14px; color: rgba(255,255,255,0.65); }
        .gate-input {
            width: 100%; padding: 14px 16px; border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.35);
            background: rgba(8, 3, 24, 0.35); color: #fff;
            font-size: 14px; letter-spacing: 4px; text-align: center; outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .gate-input:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(248, 35, 135, 0.25); }
        .gate-button {
            width: 100%; height: 44px; padding: 0 24px; border-radius: 12px;
            background: linear-gradient(120deg, var(--accent), var(--accent-secondary));
            color: #fff; font-size: 14px; font-weight: 600; border: none; cursor: pointer;
            transition: all 0.2s; display: flex; align-items: center; justify-content: center;
        }
        .gate-button:hover { transform: translateY(-1px); box-shadow: 0 12px 25px rgba(248, 35, 135, 0.35); }
        .gate-error { min-height: 18px; font-size: 14px; color: var(--danger); }

        /* Main Layout */
        .main-container {
            width: 100%;
            max-width: 100vw;
            flex: 1;
            padding: 8px 20px 20px;
            background: var(--bg-primary);
            box-shadow: var(--shadow-soft);
            border: 1px solid var(--border);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 0; margin-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }
        .app-header h1 { font-size: 14px; font-weight: 600; color: var(--text-primary); letter-spacing: 0.3px; }
        .header-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        #profile-section { display: flex; align-items: center; gap: 8px; font-size: 13px; padding: 6px 12px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 12px; flex-wrap: wrap; }
        #profile-section span:first-child { white-space: nowrap; }

        /* Three Column Layout: Left Sidebar | Main Content | Log Panel */
        .app-layout {
            display: grid;
            grid-template-columns: 50% 1fr 600px;
            gap: 20px;
            flex: 1;
            min-height: 0;
            transition: all 0.3s;
            width: 100%;
            max-width: 100vw;
            overflow: hidden;
            position: relative;
        }
        .app-layout.log-hidden { grid-template-columns: 50% 1fr 0; gap: 20px 0; }
        .app-layout.log-hidden .log-panel { opacity: 0; transform: translateX(20px); pointer-events: none; overflow: hidden; padding: 0; width: 0; }

        /* Left Sidebar - Galleries */
        .sidebar-column {
            display: flex; flex-direction: column; gap: 12px;
            height: 100%;
            overflow-y: auto;
        }
        .sidebar-column::-webkit-scrollbar { width: 4px; }
        .sidebar-column::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 2px; }

        .sidebar-section { border: 1px solid var(--border); background: var(--bg-secondary); }
        .sidebar-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 14px; border-bottom: 1px solid var(--border);
            font-weight: 600; font-size: 14px; background: var(--bg-tertiary);
        }
        .gallery-title-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
        .sidebar-content { padding: 12px; display: flex; flex-direction: column; gap: 10px; }
        .sidebar-content.collapsed { display: none; }

        .sidebar-gallery {
            display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px;
            grid-auto-rows: minmax(140px, auto); /* Increased to accommodate padding and text */
            /* Removed max-height and overflow-y to allow auto height and show all items */
        }
        .gallery-drop-zone {
            position: relative; border: 1px dashed var(--border); background: var(--bg-primary); padding: 8px;
        }
        .gallery-drop-zone.dragover { border-color: var(--accent); border-style: solid; background: var(--bg-tertiary); }

        /* Main Content Area */
        .main-content-area { 
            display: flex; flex-direction: column; gap: 16px;
            height: 100%;
            overflow-y: auto;
        }

        .preview-panel {
            display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; gap: 12px;
        }
        .preview-left-column { display: contents; }
        .preview-card {
            display: flex; flex-direction: column; gap: 8px;
            background: var(--bg-secondary); border: 1px solid var(--border);
            width: 100%; overflow: hidden;
        }
        .preview-card.preset-card { grid-column: 1; grid-row: 1; min-height: 320px; }
        .preview-card.selfie-card { grid-column: 1; grid-row: 2; min-height: 320px; }
        .preview-card.result-card { grid-column: 2; grid-row: 1 / -1; min-height: 660px; }
        .preview-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; border-bottom: 1px solid var(--border); background: var(--bg-tertiary);
        }
        .preview-label { font-size: 14px; font-weight: 600; color: var(--text-primary); }
        .preview-image {
            flex: 1; min-height: 200px; display: flex; align-items: center; justify-content: center;
            background: var(--bg-primary); overflow: hidden; padding: 8px;
            width: 100%; max-width: 100%; box-sizing: border-box;
            position: relative;
        }
        .preview-action-badge {
            position: absolute; bottom: 8px; left: 8px; z-index: 2;
            padding: 2px 6px; border-radius: 3px; font-size: 9px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.2px;
            background: rgba(0, 0, 0, 0.8); color: #fff; backdrop-filter: blur(4px);
            pointer-events: none; white-space: nowrap; line-height: 1.2;
        }
        .preview-action-badge.action-4k { background: rgba(139, 92, 246, 0.9); color: #fff; }
        .preview-action-badge.action-faceswap { background: rgba(16, 185, 129, 0.9); color: #fff; }
        .preview-action-badge.action-wedding { background: rgba(236, 72, 153, 0.9); color: #fff; }
        .preview-action-badge.action-default { background: rgba(100, 116, 139, 0.9); color: #fff; }
        .preview-card.preset-card .preview-image {
            aspect-ratio: 2 / 3;
            max-height: calc(320px - 50px);
        }
        .preview-card.selfie-card .preview-image {
            aspect-ratio: 2 / 3;
            max-height: calc(320px - 50px);
        }
        .preview-card.result-card .preview-image { 
            min-height: 600px;
            max-height: calc(660px - 50px);
        }
        .preview-image img { 
            max-width: 100% !important; 
            max-height: 100% !important; 
            width: auto !important; 
            height: auto !important; 
            object-fit: contain !important; 
            display: block;
            margin: 0 auto;
        }
        .preview-empty { display: flex; flex-direction: column; align-items: center; gap: 8px; color: var(--text-muted); text-align: center; }
        .preview-empty-icon { font-size: 32px; opacity: 0.5; }
        .preview-empty-text { font-size: 14px; }

        /* Action Panel */
        .action-panel {
            border: 1px solid var(--border); padding: 12px 16px;
            display: flex; flex-wrap: wrap; align-items: center; gap: 12px; background: var(--bg-secondary);
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }
        .action-buttons { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .action-btn {
            height: 36px; padding: 0 16px; font-size: 13px; font-weight: 600;
            border: none; background: var(--accent); color: #fff; cursor: pointer;
            display: inline-flex; align-items: center; gap: 6px;
            transition: all 0.2s; border-radius: 12px;
        }
        .action-btn:hover:not(:disabled) { background: var(--accent-hover); transform: translateY(-1px); }
        .action-btn.primary { background: var(--accent-strong); }
        .action-btn.primary:hover:not(:disabled) { background: var(--accent); }
        .action-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        .action-btn.loading::after {
            content: ''; width: 12px; height: 12px; margin-left: 6px;
            border: 2px solid transparent; border-top-color: #fff;
            border-radius: 50%; animation: spin 0.6s linear infinite;
        }

        .action-options { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 12px; 
            align-items: center; 
            width: 100%; 
            max-width: 100%;
            overflow-x: hidden;
        }
        .action-prompt {
            flex: 1; min-width: 180px; height: 36px; padding: 0 12px;
            border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 14px;
            border-radius: 12px;
        }
        .action-ratio { display: flex; gap: 6px; align-items: center; }
        .action-model { display: flex; gap: 6px; align-items: center; }
        .action-aging { display: flex; gap: 6px; align-items: center; }
        .action-aging input { width: 50px; height: 36px; padding: 0 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); text-align: center; font-size: 14px; border-radius: 12px; }

        /* History/Results Panel */
        .results-panel {
            border: 1px solid var(--border); padding: 12px; background: var(--bg-secondary);
        }
        .results-header {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 14px; font-weight: 600; margin-bottom: 12px;
        }
        .results-count { font-weight: 400; color: var(--text-muted); }
        .results-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px;
            /* Removed max-height and overflow-y to allow auto height like preset/selfie galleries */
        }

        /* Log Panel - Right Sidebar */
        .log-panel {
            background: var(--bg-secondary); border: 1px solid var(--border);
            padding: 16px; display: flex; flex-direction: column;
            height: 100%;
            overflow: hidden; transition: opacity 0.3s, transform 0.3s;
        }
        .log-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 8px; }
        .log-title { font-size: 14px; font-weight: 600; color: var(--accent-strong); flex: 1; }
        .log-toggle-btn, .log-clear-btn {
            padding: 5px 12px; border: none; cursor: pointer;
            font-size: 13px; font-weight: 600; border-radius: 12px; transition: all 0.2s;
        }
        .log-toggle-btn { background: var(--accent); color: #fff; }
        .log-toggle-btn:hover { background: var(--accent-hover); }
        .log-clear-btn { background: var(--danger); color: #fff; }
        .log-clear-btn:hover { background: #dc2626; }

        .api-log-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; }
        .api-log-entry {
            border: 1px solid var(--border); padding: 8px; background: var(--bg-primary); font-size: 12px;
        }
        .api-log-entry.log-error { border-left: 3px solid var(--danger); }
        .api-log-entry.log-success { border-left: 3px solid var(--success); }
        .api-log-entry.log-info { border-left: 3px solid var(--accent); }
        .api-log-main { font-size: 12px; color: var(--text-primary); line-height: 1.4; }
        .api-log-method { font-weight: 600; color: var(--accent); }
        .api-log-url { color: var(--text-secondary); word-break: break-all; }
        .api-log-timing { color: #666; font-size: 11px; margin-left: 6px; }
        .api-log-payload { margin-top: 6px; font-size: 11px; background: rgba(0,0,0,0.03); padding: 8px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        .api-log-curl-wrapper { margin-top: 8px; position: relative; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 4px; }
        .api-log-curl-pre { overflow-x: auto; font-size: 11px; white-space: pre-wrap; word-wrap: break-word; word-break: break-all; margin: 0; padding-right: 60px; }
        .api-log-copy-btn { position: absolute; top: 8px; right: 8px; background: var(--accent); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; opacity: 0.8; }
        .api-log-copy-btn:hover { opacity: 1; }

        /* Gallery Items */
        .gallery-item {
            aspect-ratio: 1; overflow: hidden; background: var(--bg-primary);
            border: 1px solid var(--border); cursor: pointer; position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        /* Preset and Selfie gallery items use 2:3 aspect ratio */
        #preset-gallery .gallery-item,
        #selfie-gallery .gallery-item {
            aspect-ratio: 2 / 3;
        }
        .gallery-item.selected { border-color: var(--accent); border-width: 2px; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); }
        .gallery-item:hover { transform: translateY(-2px); box-shadow: var(--shadow-soft); }
        .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
        .gallery-action-badge {
            position: absolute; bottom: 4px; left: 4px; z-index: 2;
            padding: 1px 3px; border-radius: 2px; font-size: 8px; font-weight: 600;
            text-transform: uppercase; letter-spacing: 0.1px;
            background: rgba(0, 0, 0, 0.8); color: #fff; backdrop-filter: blur(4px);
            pointer-events: none; white-space: nowrap; line-height: 1.1;
        }
        .gallery-action-badge.action-4k { background: rgba(139, 92, 246, 0.9); color: #fff; }
        .gallery-action-badge.action-faceswap { background: rgba(16, 185, 129, 0.9); color: #fff; }
        .gallery-action-badge.action-wedding { background: rgba(236, 72, 153, 0.9); color: #fff; }
        .gallery-action-badge.action-default { background: rgba(100, 116, 139, 0.9); color: #fff; }
        .gallery-delete-btn {
            position: absolute; top: 4px; right: 4px; width: 22px; height: 22px;
            background: var(--danger); color: #fff; border: none; border-radius: 12px;
            font-size: 14px; font-weight: 700; cursor: pointer; opacity: 0;
            display: flex; align-items: center; justify-content: center; z-index: 10;
        }
        .gallery-item:hover .gallery-delete-btn { opacity: 1; }
        .gallery-delete-btn:hover { background: #dc2626; }

        .gallery-upload-btn {
            width: 28px; height: 28px; border: none; background: var(--accent);
            color: #fff; cursor: pointer; font-size: 16px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            border-radius: 12px; transition: all 0.2s;
        }
        .gallery-upload-btn:hover { background: var(--accent-hover); transform: scale(1.1); }


        /* Pagination */
        .pagination { 
            display: flex; align-items: center; justify-content: center; gap: 6px; 
            margin-top: 12px; flex-wrap: wrap; max-width: 100%; 
        }
        .pagination-btn {
            width: 32px; height: 32px; padding: 0; background: var(--accent); border: none;
            color: #fff; font-size: 12px; font-weight: 600; cursor: pointer;
            transition: all 0.2s; border-radius: 12px; flex-shrink: 0;
        }
        .pagination-btn:hover:not(:disabled) { background: var(--accent-hover); }
        .pagination-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .pagination-numbers { 
            display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; 
            max-width: 100%; overflow: hidden;
        }
        .pagination-number {
            width: 32px; height: 32px; padding: 0; background: var(--bg-secondary);
            color: var(--text-primary); font-size: 12px; font-weight: 600; cursor: pointer;
            border: 1px solid var(--border); border-radius: 6px;
            transition: all 0.2s; display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
        }
        .pagination-number:hover:not(.active) { background: var(--bg-tertiary); border-color: var(--accent); }
        .pagination-number.active { background: var(--accent); color: #fff; border-color: var(--accent); }

        /* Delete button in preview */
        .delete-btn {
            width: 24px; height: 24px; background: var(--danger); color: #fff;
            border: none; border-radius: 12px; cursor: pointer;
            font-size: 16px; font-weight: 700;
        }
        .delete-btn:hover { background: #dc2626; }

        /* Lightbox */
        .lightbox {
            position: fixed; inset: 0; z-index: 10000;
            display: flex; align-items: center; justify-content: center;
            width: 100vw; height: 100vh;
            overflow: hidden;
            top: 0; left: 0; right: 0; bottom: 0;
        }
        .lightbox-overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); cursor: pointer; }
        .lightbox-content { 
            position: relative; 
            max-width: 90vw; 
            max-height: 90vh; 
            height: auto;
            z-index: 10001; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            padding: 20px;
            overflow: visible;
        }
        .lightbox-single { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            width: 100%; 
            max-height: 100%;
            overflow: visible;
            padding: 20px;
        }
        .lightbox-content img { max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; }
        .lightbox-info { 
            margin-top: 16px; 
            margin-bottom: 16px;
            color: #fff; 
            font-size: 14px; 
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            max-width: 90%;
            width: 90%;
            word-wrap: break-word;
            z-index: 10;
            position: relative;
        }
        .lightbox-actions {
            position: relative;
            display: flex; 
            gap: 12px; 
            justify-content: center; 
            flex-wrap: wrap;
            margin-top: 20px;
            width: 100%;
            padding: 0 20px;
        }
        .lightbox-action-btn {
            padding: 10px 20px; background: rgba(139, 92, 246, 0.9); border: none; border-radius: 8px;
            color: #fff; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; gap: 6px;
        }
        .lightbox-action-btn:hover { background: rgba(139, 92, 246, 1); transform: translateY(-2px); }
        .lightbox-action-btn:active { transform: translateY(0); }
        .lightbox-action-btn.secondary { background: rgba(59, 130, 246, 0.9); }
        .lightbox-action-btn.secondary:hover { background: rgba(59, 130, 246, 1); }
        .lightbox-action-btn.danger { background: rgba(239, 68, 68, 0.9); }
        .lightbox-action-btn.danger:hover { background: rgba(239, 68, 68, 1); }
        .lightbox-close, .lightbox-nav {
            position: absolute; width: 40px; height: 40px;
            background: rgba(255,255,255,0.2); border: none; border-radius: 12px;
            color: #fff; font-size: 28px; cursor: pointer; z-index: 10002;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        .lightbox-close { top: 20px; right: 20px; }
        .lightbox-close:hover, .lightbox-nav:hover { background: rgba(255,255,255,0.3); }
        .lightbox-nav { top: 50%; transform: translateY(-50%); }
        .lightbox-prev { left: 20px; }
        .lightbox-next { right: 20px; }
        .lightbox-nav:disabled { opacity: 0.3; cursor: not-allowed; }
        
        /* Comparison Mode */
        .lightbox-comparison { width: 100%; max-width: 100%; }
        .comparison-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; color: #fff;
        }
        .comparison-header h3 { margin: 0; font-size: 18px; font-weight: 600; }
        .comparison-grid {
            display: grid; gap: 16px; width: 100%;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            max-height: 60vh; overflow: hidden; padding: 10px;
        }
        .comparison-grid.compare-2 { grid-template-columns: 1fr 1fr; }
        .comparison-grid.compare-3 { grid-template-columns: 1fr 1fr 1fr; }
        .comparison-item {
            position: relative; background: rgba(255,255,255,0.1);
            border-radius: 8px; padding: 10px; display: flex; flex-direction: column;
        }
        .comparison-item img {
            width: 100%; max-height: 50vh; object-fit: contain;
            border-radius: 4px; margin-bottom: 8px;
        }
        .comparison-item-label {
            color: #fff; font-size: 12px; text-align: center;
            margin-bottom: 8px; font-weight: 500;
        }
        .comparison-item-remove {
            position: absolute; top: 5px; right: 5px;
            width: 28px; height: 28px; background: rgba(239, 68, 68, 0.9);
            border: none; border-radius: 50%; color: #fff; font-size: 16px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s; z-index: 10;
        }
        .comparison-item-remove:hover { background: rgba(239, 68, 68, 1); transform: scale(1.1); }
        .comparison-actions {
            margin-top: 20px; display: flex; justify-content: center;
        }
        @media (max-width: 768px) {
            .comparison-grid.compare-2,
            .comparison-grid.compare-3 {
                grid-template-columns: 1fr;
            }
        }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed; inset: 0; z-index: 10003;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.8);
        }
        .modal-content {
            background: var(--bg-primary); border-radius: 12px;
            padding: 24px; max-width: 600px; width: 90%;
            max-height: 80vh;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 12px;
        }
        .modal-header h2 { margin: 0; font-size: 18px; font-weight: 600; color: var(--text-primary); }
        .modal-close {
            width: 32px; height: 32px; background: rgba(239, 68, 68, 0.9);
            border: none; border-radius: 8px; color: #fff; font-size: 20px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .modal-close:hover { background: rgba(239, 68, 68, 1); transform: scale(1.1); }
        .modal-body { 
            color: var(--text-primary); 
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }
        .progress-bar {
            width: 100%; height: 8px; background: var(--bg-secondary);
            border-radius: 4px; overflow: hidden; margin-top: 8px;
        }
        .progress-fill {
            height: 100%; background: var(--accent); transition: width 0.3s;
            width: 0%;
        }
        .thumbnail-item {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 8px; padding: 8px; text-align: center;
        }
        .thumbnail-item img {
            width: 100%; height: 120px; object-fit: contain;
            border-radius: 4px; margin-bottom: 8px;
        }
        .thumbnail-item-info {
            font-size: 11px; color: var(--text-muted);
            word-break: break-word;
        }
        /* Main Tabs */
        .main-tabs {
            display: flex; gap: 8px; margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        .main-tab {
            padding: 12px 24px; background: none; border: none;
            border-bottom: 2px solid transparent; margin-bottom: -2px;
            color: var(--text-secondary); font-size: 15px; font-weight: 600;
            cursor: pointer; transition: all 0.2s;
        }
        .main-tab:hover {
            color: var(--accent);
        }
        .main-tab.active {
            color: var(--accent); border-bottom-color: var(--accent);
        }
        .main-tab-content {
            display: none;
        }
        .main-tab-content.active {
            display: block;
        }
        
        /* Thumbnails Tab Container */
        .thumbnails-tab-container {
            display: flex; flex-direction: column; gap: 16px;
        }
        .thumbnails-tab-header {
            margin-bottom: 8px;
        }
        .thumbnails-tabs {
            display: flex; gap: 8px;
            border-bottom: 2px solid var(--border);
        }
        .thumbnail-subtab {
            padding: 10px 20px; background: none; border: none;
            border-bottom: 2px solid transparent; margin-bottom: -2px;
            color: var(--text-secondary); font-size: 14px; font-weight: 600;
            cursor: pointer; transition: all 0.2s;
        }
        .thumbnail-subtab:hover {
            color: var(--accent);
        }
        .thumbnail-subtab.active {
            color: var(--accent); border-bottom-color: var(--accent);
        }
        .thumbnail-subtab-content {
            display: none;
        }
        .thumbnail-subtab-content.active {
            display: block;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed; inset: 0; background: rgba(253, 251, 255, 0.92);
            backdrop-filter: blur(10px); display: flex; align-items: center;
            justify-content: center; z-index: 9999;
        }
        .loading-content { background: var(--bg-secondary); border: 1px solid var(--border); padding: 24px; text-align: center; min-width: 200px; border-radius: 12px; }
        .spinner { width: 36px; height: 36px; border: 3px solid rgba(139, 92, 246, 0.2); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.6s linear infinite; margin: 0 auto 12px; }
        .loading-text { font-size: 14px; color: var(--accent); font-weight: 600; }
        .loading-subtext { font-size: 13px; color: var(--text-muted); margin-top: 4px; }
        .loading-timer { font-size: 16px; color: var(--accent-strong); font-weight: 700; margin-top: 8px; font-family: monospace; }

        /* Toast */
        .toast-container { position: fixed; top: 20px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 12px; pointer-events: none; }
        .toast {
            pointer-events: auto; min-width: 280px; max-width: 400px;
            padding: 12px 16px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            display: flex; align-items: flex-start; gap: 12px; animation: toastSlideIn 0.3s ease-out;
        }
        .toast.toast-success { background: linear-gradient(135deg, #10b981, #059669); color: #fff; border-left: 4px solid #34d399; }
        .toast.toast-error { background: linear-gradient(135deg, #ef4444, #dc2626); color: #fff; border-left: 4px solid #f87171; }
        .toast.toast-info { background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; border-left: 4px solid #60a5fa; }
        .toast-content { flex: 1; font-size: 14px; }
        .toast-close { background: none; border: none; color: #fff; font-size: 18px; cursor: pointer; padding: 0; opacity: 0.8; }
        .toast-close:hover { opacity: 1; }

        /* Status Message */
        .status-message {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 20px; font-size: 14px; border-radius: 12px; z-index: 9999;
            display: flex; align-items: center; gap: 8px; animation: slideIn 0.2s ease;
        }
        .status-success { background: rgba(43, 201, 144, 0.95); color: #fff; }
        .status-error { background: rgba(255, 77, 109, 0.95); color: #fff; }
        .status-info { background: rgba(248, 35, 135, 0.95); color: #fff; }
        .status-close { background: none; border: none; color: #fff; font-size: 18px; cursor: pointer; margin-left: 8px; }

        /* Float Toggle */
        .log-toggle-float {
            position: fixed; right: 20px; bottom: 20px; width: 50px; height: 50px;
            background: linear-gradient(120deg, var(--accent), var(--accent-secondary));
            border: none; color: #fff; font-size: 20px; cursor: pointer; border-radius: 12px;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.4);
            display: none; align-items: center; justify-content: center; z-index: 9999;
        }
        .log-toggle-float:hover { transform: scale(1.1); }
        .app-layout.log-hidden .log-toggle-float { display: flex !important; }

        .file-input { display: none; }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-50%) translateY(10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        @keyframes toastSlideIn { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } }

        /* Responsive */
        @media (max-width: 1600px) {
            .sidebar-gallery {
                grid-template-columns: repeat(8, 1fr);
                gap: 5px;
            }
        }
        @media (max-width: 1400px) {
            .app-layout { grid-template-columns: 45% 1fr 500px; }
            .app-layout.log-hidden { grid-template-columns: 45% 1fr 0; }
            .sidebar-gallery {
                grid-template-columns: repeat(7, 1fr);
                gap: 5px;
            }
        }
        @media (max-width: 1200px) {
            .app-layout { grid-template-columns: 1fr; }
            .sidebar-column { max-height: none; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
            .sidebar-gallery {
                grid-template-columns: repeat(5, 1fr);
                gap: 6px;
            }
            .preview-panel { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
            .preview-card.preset-card { grid-column: 1; grid-row: 1; }
            .preview-card.selfie-card { grid-column: 1; grid-row: 2; }
            .preview-card.result-card { grid-column: 2; grid-row: 1 / -1; }
            .log-panel { position: relative; top: 0; max-height: 400px; margin-top: 16px; }
            .log-toggle-float { display: none !important; }
        }
        @media (max-width: 768px) {
            html, body {
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
                position: relative;
                touch-action: pan-y pan-x;
                -ms-touch-action: pan-y pan-x;
                -webkit-overflow-scrolling: touch;
            }
            .main-container { 
                padding: 12px; 
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
            }
            .app-layout { 
                grid-template-columns: 1fr; 
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
            }
            .app-header { flex-direction: column; align-items: flex-start; gap: 8px; }
            .header-controls { width: 100%; gap: 6px; max-width: 100%; overflow-x: hidden; }
            #profile-section { 
                font-size: 11px; 
                padding: 4px 8px; 
                gap: 4px; 
                width: 100%; 
                max-width: 100%;
            }
            #profile-section span:first-child { display: none; }
            #profile-section #profile-id-input { 
                width: 80px; 
                height: 24px; 
                font-size: 11px; 
                padding: 2px 6px; 
            }
            #profile-section #switch-profile-btn { 
                padding: 2px 8px; 
                font-size: 11px; 
                height: 24px; 
                white-space: nowrap;
            }
            #profile-section #profile-status { font-size: 11px; }
            #profile-section #profile-id-display { font-size: 10px; }
            .sidebar-column { grid-template-columns: 1fr; }
            .sidebar-gallery {
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
            }
            .preview-panel { grid-template-columns: 1fr; grid-template-rows: auto auto auto; }
            .preview-card.preset-card { grid-column: 1; grid-row: 1; min-height: 250px; }
            .preview-card.selfie-card { grid-column: 1; grid-row: 2; min-height: 250px; }
            .preview-card.result-card { grid-column: 1; grid-row: 3; min-height: 400px; }
            .preview-card.result-card .preview-image { min-height: 350px; }
            .action-panel { 
                flex-direction: column; 
                align-items: stretch; 
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
                padding: 12px;
            }
            .action-buttons { 
                flex-direction: column; 
                width: 100%;
                max-width: 100%;
            }
            .action-btn { 
                width: 100%; 
                max-width: 100%;
                justify-content: center; 
            }
            .action-options {
                width: 100%;
                max-width: 100vw;
                overflow-x: hidden;
                flex-direction: column;
                align-items: stretch;
            }
            .action-prompt {
                width: 100%;
                max-width: 100%;
                min-width: 100%;
            }
            .action-ratio, .action-model {
                width: 100%;
                max-width: 100%;
            }
            .action-ratio select, .action-model select {
                width: 100%;
                max-width: 100%;
                flex: 1;
            }
            .results-grid { 
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); 
            }
            * {
                max-width: 100vw;
            }
            img, video, iframe {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div id="access-gate" class="access-gate">
        <div class="gate-card">
            <div class="gate-title">Restricted Workspace</div>
            <div class="gate-subtitle">Nh·∫≠p m√£ truy c·∫≠p ƒë·ªÉ ti·∫øp t·ª•c</div>
            <input type="password" id="access-input" class="gate-input" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="off" autocapitalize="off" spellcheck="false">
            <button id="access-submit" class="gate-button">Unlock</button>
            <div id="access-error" class="gate-error"></div>
        </div>
    </div>

    <div class="main-container">
        <div class="app-header">
            <h1>ƒê·ªïi M·∫∑t AI (Face Swap AI)</h1>
            <div class="header-controls">
                <div id="profile-section">
                    <span style="color: var(--text-secondary);">H·ªì S∆° (Profile):</span>
                    <span id="profile-status" style="color: var(--text-muted);">ƒêang t·∫£i...</span>
                    <span id="profile-info" style="display: none;">
                        <span id="profile-id-display" style="font-family: monospace; color: var(--accent); font-size: 12px;"></span>
                    </span>
                    <input type="text" id="profile-id-input" placeholder="ID Profile" style="padding: 4px 8px; border: 1px solid var(--border); border-radius: 12px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px; font-family: monospace; width: 100px; height: 26px;">
                    <button id="switch-profile-btn" onclick="switchProfile()" style="padding: 4px 12px; background: var(--accent); color: #fff; border: none; cursor: pointer; font-size: 12px; height: 26px; font-weight: 600; border-radius: 12px;">Chuy·ªÉn Profile</button>
                    <button id="edit-profile-btn" onclick="openProfileEditModal()" style="padding: 4px 12px; background: rgba(59, 130, 246, 0.9); color: #fff; border: none; cursor: pointer; font-size: 12px; height: 26px; font-weight: 600; border-radius: 12px; display: none;" title="Ch·ªânh S·ª≠a H·ªì S∆°">‚úèÔ∏è S·ª≠a</button>
                </div>
                <button class="log-toggle-btn" onclick="window.open('docs/index.html', '_blank')" style="padding: 5px 12px; border: none; cursor: pointer; font-size: 13px; font-weight: 600; border-radius: 12px; background: var(--accent); color: #fff; transition: all 0.2s;">üìñ API Docs</button>
                <button class="log-toggle-btn" onclick="window.open('api-test.html', '_blank')" style="padding: 5px 12px; border: none; cursor: pointer; font-size: 13px; font-weight: 600; border-radius: 12px; background: var(--success); color: #fff; transition: all 0.2s;" title="API Auto-Test">üß™ API Test</button>
                <button class="log-toggle-btn" onclick="showComparisonView()" id="comparison-view-btn" style="padding: 5px 12px; border: none; cursor: pointer; font-size: 13px; font-weight: 600; border-radius: 12px; background: rgba(59, 130, 246, 0.9); color: #fff; transition: all 0.2s;" title="Xem So S√°nh">üîç So S√°nh (<span id="comparison-count">0</span>)</button>
                <button class="log-toggle-btn" onclick="toggleLogPanel()">Nh·∫≠t K√Ω (Log)</button>
            </div>
        </div>

        <div class="app-layout log-hidden">
            <!-- Left Sidebar - Galleries -->
            <div class="sidebar-column">
                <div class="sidebar-section">
                    <div class="sidebar-header">
                        <div class="gallery-title-row">
                            <span id="preset-title">M·∫´u (Presets)</span>
                        </div>
                        <button class="gallery-upload-btn" onclick="document.getElementById('preset-input').click()">+</button>
                        <input type="file" class="file-input" id="preset-input" accept="image/*" multiple>
                    </div>
                    <div style="padding: 8px 12px; border-bottom: 1px solid var(--border);">
                        <div style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                            <input type="text" id="preset-search-input" placeholder="üîç T√¨m ki·∫øm..." style="flex: 1; min-width: 120px; padding: 6px 8px; font-size: 11px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary);" autocomplete="off">
                            <select id="preset-parent-category-select" style="flex: 0 0 auto; min-width: 80px; padding: 6px 8px; font-size: 11px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); cursor: pointer;" onchange="handlePresetParentCategoryChange(this.value)">
                                <option value="All">All</option>
                                <option value="fs">fs</option>
                                <option value="ft">ft</option>
                                <option value="Other">Other</option>
                            </select>
                            <select id="preset-category-select" style="flex: 0 0 auto; min-width: 100px; padding: 6px 8px; font-size: 11px; border: 1px solid var(--border); border-radius: 6px; background: var(--bg-primary); color: var(--text-primary); cursor: pointer;" onchange="handlePresetCategoryChange(this.value)">
                                <option value="Other">Other</option>
                            </select>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer; white-space: nowrap;">
                                <input type="checkbox" id="preset-filter-mode" style="cursor: pointer; margin: 0;">
                                <span style="color: var(--text-secondary);">üé® Art</span>
                            </label>
                            <button onclick="openPromptCustomizer()" style="flex: 0 0 auto; padding: 6px 8px; font-size: 11px; background: rgba(139, 92, 246, 0.1); border: 1px solid var(--accent); color: var(--accent); border-radius: 6px; cursor: pointer; font-weight: 500; white-space: nowrap;">
                                ‚öôÔ∏è
                            </button>
                        </div>
                    </div>
                    <div class="sidebar-content" id="preset-sidebar-content">
                        <div class="gallery-drop-zone" id="preset-drop-zone">
                            <div id="preset-gallery" class="sidebar-gallery"></div>
                        </div>
                        <div class="pagination" id="preset-pagination" style="display: none;">
                            <button class="pagination-btn" id="preset-prev" onclick="changePage('preset', -1)">‚óÄ</button>
                            <div class="pagination-numbers" id="preset-dots"></div>
                            <button class="pagination-btn" id="preset-next" onclick="changePage('preset', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>
                <div class="sidebar-section">
                    <div class="sidebar-header">
                        <span>·∫¢nh T·ª± S∆∞·ªõng (Selfies)</span>
                        <button class="gallery-upload-btn" onclick="document.getElementById('selfie-input').click()">+</button>
                        <input type="file" class="file-input" id="selfie-input" accept="image/*" multiple>
                    </div>
                    <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color);">
                        <label for="selfie-action-select" style="display: block; font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Action:</label>
                        <select id="selfie-action-select" style="width: 100%; padding: 6px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 13px;">
                            <option value="faceswap" selected>Faceswap (Max 8)</option>
                            <option value="wedding">Wedding (Max 2)</option>
                            <option value="4k">4K Upscale (Max 1)</option>
                            <option value="default">Default (Max 1)</option>
                        </select>
                    </div>
                    <div class="sidebar-content" id="selfie-sidebar-content">
                        <div class="gallery-drop-zone" id="selfie-drop-zone">
                            <div id="selfie-gallery" class="sidebar-gallery"></div>
                        </div>
                        <div class="pagination" id="selfie-pagination" style="display: none;">
                            <button class="pagination-btn" id="selfie-prev" onclick="changePage('selfie', -1)">‚óÄ</button>
                            <div class="pagination-numbers" id="selfie-dots"></div>
                            <button class="pagination-btn" id="selfie-next" onclick="changePage('selfie', 1)">‚ñ∂</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="main-content-area">
                <!-- Main Tabs -->
                <div class="main-tabs">
                    <button class="main-tab active" onclick="switchMainTab('faceswap')" id="main-tab-faceswap">
                        ‚ú® ƒê·ªïi M·∫∑t (Face Swap)
                    </button>
                    <button class="main-tab" onclick="switchMainTab('thumbnails')" id="main-tab-thumbnails">
                        üñºÔ∏è Thumbnails
                    </button>
                </div>

                <!-- Face Swap Tab Content -->
                <div id="faceswap-tab-content" class="main-tab-content active">
                    <div class="preview-panel">
                        <div class="preview-card preset-card" id="preset-card">
                            <div class="preview-header">
                                <div class="preview-label">M·∫´u (Preset)</div>
                                <button class="delete-btn" onclick="clearSelection('preset', event)" style="display: none;" id="preset-clear-btn">√ó</button>
                            </div>
                            <div id="preset-preview" class="preview-image">
                                <div class="preview-empty">
                                    <div class="preview-empty-icon">üì∑</div>
                                    <div class="preview-empty-text">Ch·ªçn t·ª´ m·∫´u (Select from presets)</div>
                                </div>
                            </div>
                        </div>
                        <div class="preview-card selfie-card" id="selfie-card">
                            <div class="preview-header">
                                <div class="preview-label">·∫¢nh T·ª± S∆∞·ªõng (Selfie) - T·ªëi ƒëa 2 cho Wedding</div>
                                <button class="delete-btn" onclick="clearSelection('selfie', event)" style="display: none;" id="selfie-clear-btn">√ó</button>
                            </div>
                            <div id="selfie-preview" class="preview-image">
                                <div class="preview-empty">
                                    <div class="preview-empty-icon">üì∑</div>
                                    <div class="preview-empty-text">Ch·ªçn t·ª´ ·∫£nh t·ª± s∆∞·ªõng (Select from selfies)</div>
                                </div>
                            </div>
                        </div>
                    <div class="preview-card result-card" id="result-card">
                        <div class="preview-header">
                            <div class="preview-label">K·∫øt Qu·∫£ (Result)</div>
                        </div>
                        <div id="result-preview" class="preview-image">
                            <div class="preview-empty">
                                <div class="preview-empty-icon">‚ú®</div>
                                <div class="preview-empty-text">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y (Result will appear here)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="action-panel">
                    <div class="action-buttons">
                        <button class="action-btn primary" id="generate-btn" disabled onclick="generateFaceSwap()">
                            <span>‚ú®</span><span>ƒê·ªïi M·∫∑t (Face Swap)</span>
                        </button>
                        <button class="action-btn primary" id="merge-btn" disabled onclick="generateBackground()">
                            <span>üñºÔ∏è</span><span>T·∫°o N·ªÅn (AI Background)</span>
                        </button>
                        <button class="action-btn" id="enhance-btn" disabled onclick="runEnhance()">üîç N√¢ng C·∫•p (Enhance)</button>
                        <button class="action-btn" id="beauty-btn" disabled onclick="runBeauty()">‚ú® L√†m ƒê·∫πp (Beauty)</button>
                        <button class="action-btn" id="filter-btn" disabled onclick="runFilter()">üé® B·ªô L·ªçc (Filter)</button>
                        <button class="action-btn" id="upscale4k-btn" disabled onclick="runUpscale4k()">üìê N√¢ng C·∫•p 4K (4K Upscale)</button>
                        <button class="action-btn" id="restore-btn" disabled onclick="runRestore()">üîÑ Kh√¥i Ph·ª•c (Restore)</button>
                        <button class="action-btn" id="batch-try-btn" onclick="batchProcessTryImages()" style="background: rgba(139, 92, 246, 0.9);">üîÑ Batch Try All Presets</button>
                        <div class="action-aging">
                            <input type="number" id="aging-years" value="20" min="5" max="60" step="5">
                            <button class="action-btn" id="aging-btn" disabled onclick="runAging()">‚è≥ L√£o H√≥a (Age)</button>
                        </div>
                    </div>
                    <div class="action-options">
                        <input type="text" id="additional-prompt" class="action-prompt" placeholder="G·ª£i √Ω (t√πy ch·ªçn) / T·∫°o n·ªÅn t·ª´ text (Custom Background Prompt)">
                        <div class="action-ratio">
                            <label style="font-size: 13px; color: var(--text-secondary); margin-right: 6px;">T·ª∑ L·ªá (Ratio):</label>
                            <select id="aspect-ratio" style="height: 36px; padding: 0 12px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 13px; border-radius: 12px; cursor: pointer;">
                                <option value="original" selected>Original (T·ª´ ·∫£nh selfie)</option>
                                <option value="1:1">1:1 (Square)</option>
                                <option value="3:2">3:2 (Landscape)</option>
                                <option value="2:3">2:3 (Portrait)</option>
                                <option value="3:4">3:4 (Portrait)</option>
                                <option value="4:3">4:3 (Landscape)</option>
                                <option value="4:5">4:5 (Portrait)</option>
                                <option value="5:4">5:4 (Landscape)</option>
                                <option value="9:16">9:16 (Vertical)</option>
                                <option value="16:9">16:9 (Widescreen)</option>
                                <option value="21:9">21:9 (Ultrawide)</option>
                            </select>
                        </div>
                        <div class="action-ratio">
                            <label style="font-size: 13px; color: var(--text-secondary); margin-right: 6px;">Provider:</label>
                            <select id="image-provider" style="height: 36px; padding: 0 12px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 13px; border-radius: 12px; cursor: pointer;">
                                <option value="" selected>Default (Config)</option>
                                <option value="vertex">Vertex AI</option>
                                <option value="wavespeed">WaveSpeed</option>
                            </select>
                        </div>
                        <div class="action-model" style="display: flex; gap: 6px; align-items: center;">
                            <label style="font-size: 13px; color: var(--text-secondary); margin-right: 6px; white-space: nowrap; font-weight: 600;">Model (Nano Banana):</label>
                            <select id="gemini-model" style="height: 36px; padding: 0 12px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 13px; border-radius: 12px; cursor: pointer; min-width: 150px; font-weight: 500;">
                                <option value="2.5" selected>2.5 Flash</option>
                                <option value="3p">3 Pro</option>
                                <option value="3f">3 Flash</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="try-images-panel" style="margin-top: 20px; padding: 20px; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h3 style="margin: 0; font-size: 16px; color: var(--text-primary);">üîÑ Try Images Batch Processor</h3>
                        <button class="action-btn" id="process-try-images-btn" onclick="processTryImagesArray()" style="background: rgba(139, 92, 246, 0.9); padding: 8px 16px; font-size: 13px;">‚ñ∂ Process Array</button>
                    </div>
                    <textarea id="try-images-array-input" placeholder="Paste array of image paths here, e.g.:&#10;['/try/ai_avatar/try_1.webp', '/try/ai_avatar/try_2.webp']&#10;or just paste paths separated by newlines" style="width: 100%; min-height: 100px; padding: 12px; border: 1px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 12px; background: var(--bg-primary); color: var(--text-primary); resize: vertical;">['https://resources.d.shotpix.app/try/ai_avatar/try_1.webp','https://resources.d.shotpix.app/try/ai_avatar/try_21.webp','https://resources.d.shotpix.app/try/ai_avatar/try_3.webp']</textarea>
                    <div style="margin-top: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                        <label style="font-size: 13px; color: var(--text-secondary);">Filter by category:</label>
                        <select id="try-results-filter" style="height: 32px; padding: 0 10px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 12px; border-radius: 8px; cursor: pointer;">
                            <option value="all">All Categories</option>
                            <option value="ai_avatar" selected>AI Avatar</option>
                            <option value="ai_restore">AI Restore</option>
                            <option value="ai_enhance">AI Enhance</option>
                            <option value="ai_beauty">AI Beauty</option>
                            <option value="ai_upscale_4k">AI Upscale 4K</option>
                        </select>
                        <label style="font-size: 13px; color: var(--text-secondary); margin-left: 12px;">Exclude:</label>
                        <input type="text" id="try-exclude-presets" placeholder="e.g. fs_aging,fs_old" value="fs_aging" style="height: 32px; padding: 0 10px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 12px; border-radius: 8px; width: 140px;">
                        <button onclick="clearTryUploadsCache()" style="height: 32px; padding: 0 10px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-secondary); font-size: 11px; border-radius: 8px; cursor: pointer;" title="Clear localStorage cache of completed uploads">üóëÔ∏è Clear Cache</button>
                        <span id="try-results-count" style="font-size: 12px; color: var(--text-muted); margin-left: auto;">0 results</span>
                    </div>
                    <div id="try-results-gallery" style="margin-top: 16px; display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 12px; max-height: 400px; overflow-y: auto; padding: 8px;"></div>
                </div>

                <div class="results-panel">
                    <div class="results-header">
                        <span>L·ªãch S·ª≠ (History)</span>
                        <span class="results-count" id="results-count">(0)</span>
                    </div>
                    <div id="results-gallery" class="results-grid"></div>
                    <div class="pagination" id="results-pagination" style="display: none;">
                        <button class="pagination-btn" id="results-prev" onclick="changePage('results', -1)">‚óÄ</button>
                        <div class="pagination-numbers" id="results-dots"></div>
                        <button class="pagination-btn" id="results-next" onclick="changePage('results', 1)">‚ñ∂</button>
                    </div>
                </div>
                </div>

                <!-- Thumbnails Tab Content -->
                <div id="thumbnails-tab-content" class="main-tab-content" style="display: none;">
                    <div class="thumbnails-tab-container">
                        <div id="thumbnails-upload-section" class="thumbnail-subtab-content active" style="display: block;">
                            <div class="thumbnail-upload-section" style="padding: 20px; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border);">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                                    <h3 style="margin-top: 0;">T·∫£i L√™n Th∆∞ M·ª•c</h3>
                                    <button class="action-btn" onclick="downloadThumbnailsJson()" style="padding: 6px 12px; font-size: 12px; background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.5); color: rgba(59, 130, 246, 1);">
                                        üì• T·∫£i JSON
                                    </button>
                                </div>
                                <p style="font-size: 12px; color: var(--text-muted); margin-bottom: 12px;">
                                    K√©o th·∫£ file zip v√†o ƒë√¢y. Zip file ph·∫£i ch·ª©a th∆∞ m·ª•c <code>preset</code> v·ªõi c√°c file PNG.<br>
                                    T√™n file preset ph·∫£i theo ƒë·ªãnh d·∫°ng: <code>[type]_[sub_category]_[gender]_[position].png</code><br>
                                    V√≠ d·ª•: <code>face-swap_wedding_both_1.png</code><br>
                                    H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông t·∫°o thumbnail WebP d·ª±a tr√™n preset.
                                </p>
                                <div style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border); display: flex; flex-direction: column; gap: 12px;">
                                    <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                                        <input type="checkbox" id="thumbnail-filter-mode" style="cursor: pointer; width: 16px; height: 16px;">
                                        <span style="color: var(--text-primary);">üé® Art Style Filter Mode</span>
                                    </label>
                                    <div style="font-size: 11px; color: var(--text-muted); margin-left: 24px;">
                                        Enable if presets in this ZIP have distinct artistic styles (figurine, pop mart, clay, disney, etc.)
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 12px; padding-top: 8px; border-top: 1px solid var(--border);">
                                        <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                                            <input type="checkbox" id="thumbnail-format-webp" value="webp" checked style="cursor: pointer; width: 16px; height: 16px;">
                                            <span style="color: var(--text-primary);">üñºÔ∏è WebP Thumbnail</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; font-size: 13px; cursor: pointer; font-weight: 500;">
                                            <input type="checkbox" id="thumbnail-format-json" value="json" style="cursor: pointer; width: 16px; height: 16px;">
                                            <span style="color: var(--text-primary);">üé¨ Lottie JSON</span>
                                        </label>
                                    </div>
                                </div>
                                <div id="thumbnail-drop-zone" style="border: 2px dashed var(--border); border-radius: 12px; padding: 40px; text-align: center; background: var(--bg-primary); transition: all 0.2s; margin-bottom: 16px;">
                                    <div style="font-size: 48px; margin-bottom: 12px;">üìÅ</div>
                                    <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">K√©o th·∫£ file zip preset v√†o ƒë√¢y</div>
                                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 16px;">Zip ph·∫£i ch·ª©a th∆∞ m·ª•c "preset" v·ªõi file PNG. T·ª± ƒë·ªông t·∫°o thumbnail t·∫•t c·∫£ ƒë·ªô ph√¢n gi·∫£i WebP/JSON (1x, 1.5x, 2x, 3x, 4x).</div>
                                    <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                                        <button class="action-btn" onclick="event.stopPropagation(); $('thumbnail-zip-input').click();" style="padding: 8px 16px; font-size: 13px;">
                                            üì¶ Ch·ªçn File Zip Preset
                                        </button>
                                    </div>
                                </div>
                                <input type="file" id="thumbnail-zip-input" accept=".zip" multiple style="display: none;" onchange="handleThumbnailZipSelect(event)">
                                <div id="thumbnail-upload-progress" style="display: none;">
                                    <div class="progress-bar">
                                        <div class="progress-fill" id="thumbnail-progress-fill"></div>
                                    </div>
                                    <div id="thumbnail-upload-status" style="margin-top: 8px; font-size: 12px;"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Log Panel - Right Sidebar -->
            <div class="log-panel">
                <div class="log-header">
                    <div class="log-title">üìã Nh·∫≠t K√Ω API</div>
                    <button class="log-clear-btn" onclick="clearApiLogs()">X√≥a</button>
                    <button class="log-toggle-btn" onclick="toggleLogPanel()" title="·∫®n">‚óÄ</button>
                </div>
                <div class="api-log-list" id="api-log-list"></div>
            </div>
        </div>
    </div>

    <!-- Lightbox -->
    <div id="lightbox" class="lightbox" style="display: none;">
        <div class="lightbox-overlay" onclick="closeLightbox()"></div>
        <button class="lightbox-close" onclick="closeLightbox()">√ó</button>
        <button class="lightbox-nav lightbox-prev" onclick="lightboxNavigate(-1)">‚Äπ</button>
        <button class="lightbox-nav lightbox-next" onclick="lightboxNavigate(1)">‚Ä∫</button>
        <div class="lightbox-content" id="lightbox-content">
            <div class="lightbox-single" id="lightbox-single">
                <img id="lightbox-image" src="" alt="">
                <div class="lightbox-info"><span id="lightbox-counter"></span></div>
                <div class="lightbox-actions" id="lightbox-actions" style="display: none;">
                    <button class="lightbox-action-btn" onclick="selectAsPreset()">
                        <span>üì∏</span>
                        <span>Ch·ªçn l√†m M·∫´u</span>
                    </button>
                    <button class="lightbox-action-btn secondary" onclick="selectAsSelfie()">
                        <span>üë§</span>
                        <span>Ch·ªçn l√†m Selfie</span>
                    </button>
                    <button class="lightbox-action-btn" onclick="addToComparison()" id="add-to-comparison-btn">
                    <span>‚ûï</span>
                    <span>Th√™m v√†o So S√°nh</span>
                </button>
            </div>
            </div>
            <div class="lightbox-comparison" id="lightbox-comparison" style="display: none;">
                <div class="comparison-header">
                    <h3>So S√°nh H√¨nh ·∫¢nh</h3>
                    <button class="lightbox-action-btn danger" onclick="clearComparison()">
                        <span>üóëÔ∏è</span>
                        <span>X√≥a T·∫•t C·∫£</span>
                    </button>
                </div>
                <div class="comparison-grid" id="comparison-grid"></div>
                <div class="comparison-actions">
                    <button class="lightbox-action-btn" onclick="switchToSingleView()">
                        <span>‚Üê</span>
                        <span>Quay L·∫°i Xem ƒê∆°n</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-container" class="toast-container"></div>

    <!-- Profile Edit Modal -->
    <div id="profile-edit-modal" class="modal-overlay" style="display: none;" onclick="if(event.target.id === 'profile-edit-modal') closeProfileEditModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>‚úèÔ∏è Ch·ªânh S·ª≠a H·ªì S∆°</h2>
                <button class="modal-close" onclick="closeProfileEditModal()">√ó</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <form id="profile-edit-form" onsubmit="saveProfileEdit(event)">
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary); font-weight: 500;">T√™n (Name):</label>
                        <input type="text" id="profile-edit-name" placeholder="Nh·∫≠p t√™n" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary); font-weight: 500;">Email:</label>
                        <input type="email" id="profile-edit-email" placeholder="email@example.com" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary); font-weight: 500;">URL Avatar:</label>
                        <input type="url" id="profile-edit-avatar" placeholder="https://example.com/avatar.jpg" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 14px;">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 6px; font-size: 13px; color: var(--text-secondary); font-weight: 500;">Preferences (JSON):</label>
                        <textarea id="profile-edit-preferences" placeholder='{"theme":"dark","language":"vi"}' rows="4" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 13px; font-family: monospace; resize: vertical;"></textarea>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">C√≥ th·ªÉ ƒë·ªÉ tr·ªëng ho·∫∑c nh·∫≠p JSON h·ª£p l·ªá</div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button type="button" onclick="closeProfileEditModal()" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; font-size: 14px; font-weight: 500;">H·ªßy</button>
                        <button type="submit" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--accent); color: #fff; cursor: pointer; font-size: 14px; font-weight: 600;">üíæ L∆∞u</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Prompt Customizer Modal -->
    <div id="prompt-customizer-modal" class="modal-overlay" style="display: none;" onclick="if(event.target.id === 'prompt-customizer-modal') closePromptCustomizer()">
        <div class="modal-content" onclick="event.stopPropagation()" style="max-width: 900px; width: 95%; max-height: 80vh; overflow: hidden;">
            <div class="modal-header">
                <h2>‚öôÔ∏è Customize Vertex AI Prompts</h2>
                <button class="modal-close" onclick="closePromptCustomizer()">√ó</button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div style="margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="display: block; font-size: 14px; color: var(--text-primary); font-weight: 600;">
                            üìù Default Mode Prompt (Normal Face-Swap)
                        </label>
                        <button onclick="resetPrompt('default')" style="padding: 4px 12px; font-size: 11px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">
                            üîÑ Reset to Original
                        </button>
                    </div>
                    <textarea id="prompt-default" rows="8" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px; font-family: 'Courier New', monospace; resize: vertical; line-height: 1.5;"></textarea>
                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                        Used when "Art Style Filter Mode" checkbox is <strong>unchecked</strong>
                    </div>
                </div>
                
                <div style="margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label style="display: block; font-size: 14px; color: var(--text-primary); font-weight: 600;">
                            üé® Filter Mode Prompt (Art Style Analysis)
                        </label>
                        <button onclick="resetPrompt('filter')" style="padding: 4px 12px; font-size: 11px; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">
                            üîÑ Reset to Original
                        </button>
                    </div>
                    <textarea id="prompt-filter" rows="8" style="width: 100%; padding: 12px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-primary); color: var(--text-primary); font-size: 12px; font-family: 'Courier New', monospace; resize: vertical; line-height: 1.5;"></textarea>
                    <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                        Used when "Art Style Filter Mode" checkbox is <strong>checked</strong>
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="closePromptCustomizer()" style="padding: 10px 20px; border: 1px solid var(--border); border-radius: 8px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer; font-size: 14px; font-weight: 500;">
                        Cancel
                    </button>
                    <button onclick="saveCustomPrompts()" style="padding: 10px 20px; border: none; border-radius: 8px; background: var(--accent); color: #fff; cursor: pointer; font-size: 14px; font-weight: 600;">
                        üíæ Save Custom Prompts
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="loading-overlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text">ƒêang t·∫£i d·ªØ li·ªáu</div>
            <div class="loading-subtext">Vui l√≤ng ch·ªù...</div>
            <div class="loading-timer" id="loading-timer">0.0s</div>
        </div>
    </div>

    <button class="log-toggle-float" id="log-toggle-float" onclick="toggleLogPanel()" title="Hi·ªán Nh·∫≠t K√Ω">üìã</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script>
        // Config - Backend URL injected during deployment from deployments-secrets.json
        let WORKER_URL = 'https://api.d.shotpix.app'; // Injected during deployment - DO NOT MODIFY MANUALLY
        // Mobile API Key for authentication (set when ENABLE_MOBILE_API_KEY_AUTH is enabled in backend)
        let MOBILE_API_KEY = 'MNfs5qUDz5jjmyZjjMC5zUgIVjpTBuZehq2_fDg9cYk'; // Injected during deployment - DO NOT MODIFY MANUALLY
        const ITEMS_PER_PAGE = 40;
        const ACCESS_CODE = '123456';
        const MAX_LOG_ENTRIES = 30;
        
        // Default Vertex AI Prompts (from backend config.ts)
        const DEFAULT_PROMPTS = {
            DEFAULT: `Analyze the provided image and return a detailed description of its contents, pose, clothing, environment, HDR lighting, style, and composition in a strict JSON format. Generate a JSON object with the following keys: "prompt", "style", "lighting", "composition", "camera", and "background". For the "prompt" key, write a detailed HDR scene description based on the target image, including the character's pose, outfit, environment, atmosphere, and visual mood. In the "prompt" field, also include this exact face-swap rule: "Replace the original face with the face from the image I will upload later. Keep the person exactly as shown in the reference image with 100% identical facial features, bone structure, skin tone, and appearance. Remove all pimples, blemishes, and skin imperfections. Enhance skin texture with flawless, smooth, and natural appearance. The final face must look exactly like the face in my uploaded image with 1:1 aspect ratio, 8K ultra-high detail, ultra-sharp facial features, and professional skin retouching. Do not alter the facial structure, identity, age, or ethnicity, and preserve all distinctive facial features. Makeup, lighting, and color grading may be adjusted only to match the HDR visual look of the target scene." The generated prompt must be fully compliant with Google Play Store content policies: the description must not contain any sexual, explicit, suggestive, racy, erotic, fetish, or adult content; no exposed sensitive body areas; no provocative wording or implications; and the entire scene must remain wholesome, respectful, and appropriate for all audiences. The JSON should fully describe the image and follow the specified structure, without any extra commentary or text outside the JSON.`,
            
            FILTER: `Analyze the image the art and thematic styles and return a detailed description of its specific art styles contents. For example if its figurine, pop mart unique style, clay, disney.. to reimagine the image. Ensure the details does not specify gender to apply to any gender.`
        };
        
        // Load custom prompts from localStorage
        function loadCustomPrompts() {
            const defaultPrompt = localStorage.getItem('custom_prompt_default') || DEFAULT_PROMPTS.DEFAULT;
            const filterPrompt = localStorage.getItem('custom_prompt_filter') || DEFAULT_PROMPTS.FILTER;
            return { defaultPrompt, filterPrompt };
        }
        
        // Save custom prompts to localStorage
        function saveCustomPromptsToStorage(defaultPrompt, filterPrompt) {
            localStorage.setItem('custom_prompt_default', defaultPrompt);
            localStorage.setItem('custom_prompt_filter', filterPrompt);
        }
        
        // Open prompt customizer modal
        function openPromptCustomizer() {
            const modal = document.getElementById('prompt-customizer-modal');
            const defaultTextarea = document.getElementById('prompt-default');
            const filterTextarea = document.getElementById('prompt-filter');
            
            if (!modal) {
                return;
            }
            
            if (!defaultTextarea) {
            }
            
            if (!filterTextarea) {
            }
            
            // Show modal even if textareas are missing (they might be added later)
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Load current prompts if textareas exist
            if (defaultTextarea && filterTextarea) {
                const { defaultPrompt, filterPrompt } = loadCustomPrompts();
                defaultTextarea.value = defaultPrompt;
                filterTextarea.value = filterPrompt;
            }
        }
        
        // Close prompt customizer modal
        function closePromptCustomizer() {
            const modal = document.getElementById('prompt-customizer-modal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }
        }
        
        // Reset prompt to original
        function resetPrompt(type) {
            const textarea = type === 'default' 
                ? document.getElementById('prompt-default')
                : document.getElementById('prompt-filter');
            
            if (!textarea) return;
            
            textarea.value = type === 'default' ? DEFAULT_PROMPTS.DEFAULT : DEFAULT_PROMPTS.FILTER;
            showStatusMessage(`Reset ${type === 'default' ? 'Default' : 'Filter'} prompt to original`, 'success');
        }
        
        // Save custom prompts
        function saveCustomPrompts() {
            const defaultTextarea = document.getElementById('prompt-default');
            const filterTextarea = document.getElementById('prompt-filter');
            
            if (!defaultTextarea || !filterTextarea) return;
            
            const defaultPrompt = defaultTextarea.value.trim();
            const filterPrompt = filterTextarea.value.trim();
            
            if (!defaultPrompt || !filterPrompt) {
                showStatusMessage('Prompts cannot be empty', 'error');
                return;
            }
            
            saveCustomPromptsToStorage(defaultPrompt, filterPrompt);
            closePromptCustomizer();
            showStatusMessage('Custom prompts saved successfully!', 'success');
        }
        
        // Make functions globally accessible
        window.openPromptCustomizer = openPromptCustomizer;
        window.closePromptCustomizer = closePromptCustomizer;
        window.resetPrompt = resetPrompt;
        window.saveCustomPrompts = saveCustomPrompts;
        
        // Also attach to button directly as fallback
        document.addEventListener('DOMContentLoaded', () => {
            const promptCustomizerBtn = document.querySelector('button[onclick="openPromptCustomizer()"]');
            if (promptCustomizerBtn) {
                promptCustomizerBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    openPromptCustomizer();
                });
            }
        });
        
        // Helper function to build headers object with API key for authenticated requests
        // Returns a new headers object (does not modify anything)
        function buildHeaders(customHeaders = {}) {
            const headers = { ...customHeaders };
            if (MOBILE_API_KEY) {
                headers['X-API-Key'] = MOBILE_API_KEY;
            }
            return headers;
        }

        // Helper function to get image dimensions from a File object
        // Returns a Promise that resolves to "widthxheight" string (e.g., "128x340")
        function getImageDimensions(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectUrl = URL.createObjectURL(file);
                img.onload = () => {
                    URL.revokeObjectURL(objectUrl);
                    resolve(`${img.naturalWidth}x${img.naturalHeight}`);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(objectUrl);
                    reject(new Error('Failed to load image for dimensions'));
                };
                img.src = objectUrl;
            });
        }
        
        // Vertex AI Configuration
        // Note: Vertex AI region is configured via GOOGLE_VERTEX_LOCATION environment variable
        // Supported regions: us-central1 (default), us-east1, us-west1, europe-west1, asia-southeast1, etc.
        // Set GOOGLE_VERTEX_LOCATION in Cloudflare Workers environment variables or deployment config

        // DOM Elements
        const $ = id => document.getElementById(id);
        const presetInput = $('preset-input'), presetPreview = $('preset-preview'), presetGallery = $('preset-gallery');
        const selfieInput = $('selfie-input'), selfiePreview = $('selfie-preview'), selfieGallery = $('selfie-gallery');
        const resultsGallery = $('results-gallery'), generateBtn = $('generate-btn'), mergeBtn = $('merge-btn');
        const apiLogList = $('api-log-list'), additionalPromptInput = $('additional-prompt');
        const accessGate = $('access-gate'), accessInput = $('access-input'), accessSubmit = $('access-submit'), accessError = $('access-error');

        // Gallery Configuration
        const galleries = {
            preset: {
                key: 'preset', responseKey: 'thumbnails', endpoints: { list: '/thumbnails', delete: '/presets' },
                logName: 'Th∆∞ Vi·ªán M·∫´u', labels: { selectSuccess: 'ƒê√£ ch·ªçn m·∫´u th√†nh c√¥ng', deleteSuccess: 'ƒê√£ x√≥a m·∫´u th√†nh c√¥ng', confirmDelete: 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a m·∫´u n√†y kh√¥ng?' },
                elements: { input: presetInput, preview: presetPreview, gallery: presetGallery, pagination: $('preset-pagination'), prevBtn: $('preset-prev'), nextBtn: $('preset-next') },
                state: { items: [], selected: null, page: 1, searchQuery: '', filteredItems: [], selectedCategory: 'All', categories: [], selectedParentCategory: 'All', parentCategories: [] }
            },
            selfie: {
                key: 'selfie', responseKey: 'selfies', endpoints: { list: '/selfies', delete: '/selfies' },
                logName: 'Th∆∞ Vi·ªán Selfie', labels: { selectSuccess: 'ƒê√£ ch·ªçn selfie th√†nh c√¥ng', deleteSuccess: 'ƒê√£ x√≥a selfie th√†nh c√¥ng', confirmDelete: 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a selfie n√†y kh√¥ng?' },
                elements: { input: selfieInput, preview: selfiePreview, gallery: selfieGallery, pagination: $('selfie-pagination'), prevBtn: $('selfie-prev'), nextBtn: $('selfie-next') },
                state: { items: [], selected: [], page: 1 }
            },
            results: {
                key: 'results', responseKey: 'results', endpoints: { list: '/results', delete: '/results' },
                logName: 'K·∫øt Qu·∫£ ƒê·ªïi M·∫∑t', labels: { deleteSuccess: 'ƒê√£ x√≥a k·∫øt qu·∫£ th√†nh c√¥ng', confirmDelete: 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a k·∫øt qu·∫£ n√†y kh√¥ng?' },
                elements: { gallery: resultsGallery, pagination: $('results-pagination'), prevBtn: $('results-prev'), nextBtn: $('results-next') },
                state: { items: [], selected: null, page: 1 }
            }
        };

        // Profile Manager
        window.profileManager = {
            currentProfile: null,
            async initializeProfile() {
                const statusDiv = $('profile-status');
                statusDiv.textContent = 'ƒêang t·∫£i...';
                try {
                    let profileId = localStorage.getItem('userProfileId');
                    if (profileId) {
                        const startTime = Date.now();
                        const profileUrl = `${WORKER_URL}/profiles/${profileId}`;
                        const response = await fetch(profileUrl, { headers: buildHeaders() });
                        const duration = Date.now() - startTime;
                        if (response.ok) {
                const data = await response.json();
                logApiCall({ label: 'L·∫•y H·ªì S∆°', method: 'GET', url: `/profiles/${profileId}`, fullUrl: profileUrl, status: 'success', duration });
                this.currentProfile = data.data || data;
                            this.updateProfileDisplay();
                            await Promise.all([loadGallery('selfie'), loadGallery('results')]);
                            updateGenerateButton();
                            updateImageOperationButtons();
                            return this.currentProfile;
                        }
                        localStorage.removeItem('userProfileId');
                    }
                    const profile = await this.createProfile();
                    localStorage.setItem('userProfileId', profile.id);
                    this.currentProfile = profile;
                    this.updateProfileDisplay();
                    await Promise.all([loadGallery('selfie'), loadGallery('results')]);
                    updateGenerateButton();
                    updateImageOperationButtons();
                    return profile;
                } catch (error) {
                    statusDiv.textContent = '‚úó L·ªói';
                    statusDiv.style.color = 'var(--danger)';
                }
            },
            async createProfile() {
                const startTime = Date.now();
                const createProfileUrl = `${WORKER_URL}/profiles`;
                // Get or generate device_id
                let deviceId = localStorage.getItem('deviceId');
                if (!deviceId) {
                    deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                    localStorage.setItem('deviceId', deviceId);
                }
                const requestBody = { device_id: deviceId };
                const response = await fetch(createProfileUrl, { method: 'POST', headers: buildHeaders({ 'Content-Type': 'application/json' }), body: JSON.stringify(requestBody) });
                const duration = Date.now() - startTime;
                if (!response.ok) throw new Error('Kh√¥ng th·ªÉ t·∫°o h·ªì s∆°');
                const data = await response.json();
                logApiCall({ label: 'T·∫°o H·ªì S∆°', method: 'POST', url: '/profiles', fullUrl: createProfileUrl, status: 'success', payload: data, duration, headers: { 'Content-Type': 'application/json' }, body: requestBody });
                return data.data || data;
            },
            updateProfileDisplay() {
                const statusDiv = $('profile-status'), infoDiv = $('profile-info'), idSpan = $('profile-id-display');
                const editBtn = $('edit-profile-btn');
                if (!this.currentProfile) { statusDiv.textContent = 'Ch∆∞a c√≥ h·ªì s∆°'; if (editBtn) editBtn.style.display = 'none'; return; }
                statusDiv.textContent = '‚úì S·∫µn s√†ng';
                statusDiv.style.color = 'var(--success)';
                if (idSpan) idSpan.textContent = this.currentProfile.id;
                if (infoDiv) infoDiv.style.display = 'inline';
                if (editBtn) editBtn.style.display = 'inline-block';
            },
            async updateProfile(updates) {
                if (!this.currentProfile?.id) throw new Error('Kh√¥ng c√≥ h·ªì s∆° ƒë·ªÉ c·∫≠p nh·∫≠t');
                const startTime = Date.now();
                const updateUrl = `${WORKER_URL}/profiles/${this.currentProfile.id}`;
                const response = await fetch(updateUrl, {
                    method: 'PUT',
                    headers: buildHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify(updates)
                });
                const duration = Date.now() - startTime;
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.message || `HTTP ${response.status}`);
                }
                const data = await response.json();
                logApiCall({
                    label: 'C·∫≠p Nh·∫≠t H·ªì S∆°',
                    method: 'PUT',
                    url: `/profiles/${this.currentProfile.id}`,
                    fullUrl: updateUrl,
                    status: 'success',
                    payload: data,
                    duration,
                    headers: { 'Content-Type': 'application/json' },
                    body: updates
                });
                this.currentProfile = data.data || data;
                this.updateProfileDisplay();
                return this.currentProfile;
            },
            async switchToProfile(profileId) {
                if (!profileId?.trim()) { showStatusMessage('Vui l√≤ng nh·∫≠p ID h·ªì s∆°', 'error'); return; }
                const statusDiv = $('profile-status');
                statusDiv.textContent = 'ƒêang chuy·ªÉn...';
                showLoading('ƒêang chuy·ªÉn h·ªì s∆°...');
                try {
                    const startTime = Date.now();
                    const getProfileUrl = `${WORKER_URL}/profiles/${profileId.trim()}`;
                    const response = await fetch(getProfileUrl, { headers: buildHeaders() });
                    const duration = Date.now() - startTime;
                    if (!response.ok) throw new Error(response.status === 404 ? 'Kh√¥ng t√¨m th·∫•y h·ªì s∆°' : `HTTP ${response.status}`);
                    const data = await response.json();
                    logApiCall({ label: 'L·∫•y H·ªì S∆°', method: 'GET', url: `/profiles/${profileId.trim()}`, fullUrl: getProfileUrl, status: 'success', duration });
                    this.currentProfile = data.data || data;
                    localStorage.setItem('userProfileId', this.currentProfile.id);
                    this.updateProfileDisplay();
                    await Promise.all([loadGallery('selfie'), loadGallery('results')]);
                    updateResultsCount();
                    updateGenerateButton();
                    updateImageOperationButtons();
                    showStatusMessage('ƒê√£ chuy·ªÉn h·ªì s∆° th√†nh c√¥ng', 'success');
                } catch (error) {
                    statusDiv.textContent = '‚úó L·ªói';
                    statusDiv.style.color = 'var(--danger)';
                    showStatusMessage(`Chuy·ªÉn h·ªì s∆° th·∫•t b·∫°i: ${error.message}`, 'error');
                } finally {
                    hideLoading();
                }
            }
        };

        function switchProfile() {
            const input = $('profile-id-input');
            if (input?.value.trim()) {
                window.profileManager.switchToProfile(input.value.trim());
                input.value = '';
            }
        }

        function openProfileEditModal() {
            const profile = window.profileManager?.currentProfile;
            if (!profile) {
                showStatusMessage('Kh√¥ng c√≥ h·ªì s∆° ƒë·ªÉ ch·ªânh s·ª≠a', 'error');
                return;
            }
            const modal = $('profile-edit-modal');
            const nameInput = $('profile-edit-name');
            const emailInput = $('profile-edit-email');
            const avatarInput = $('profile-edit-avatar');
            const preferencesInput = $('profile-edit-preferences');
            
            if (nameInput) nameInput.value = profile.name || '';
            if (emailInput) emailInput.value = profile.email || '';
            if (avatarInput) avatarInput.value = profile.avatar_url || '';
            if (preferencesInput) {
                try {
                    const prefs = typeof profile.preferences === 'string' 
                        ? JSON.parse(profile.preferences) 
                        : profile.preferences;
                    preferencesInput.value = prefs ? JSON.stringify(prefs, null, 2) : '';
                } catch (e) {
                    preferencesInput.value = profile.preferences || '';
                }
            }
            
            if (modal) modal.style.display = 'flex';
        }

        function closeProfileEditModal() {
            const modal = $('profile-edit-modal');
            if (modal) modal.style.display = 'none';
        }

        async function saveProfileEdit(event) {
            event.preventDefault();
            const profile = window.profileManager?.currentProfile;
            if (!profile?.id) {
                showStatusMessage('Kh√¥ng c√≥ h·ªì s∆° ƒë·ªÉ c·∫≠p nh·∫≠t', 'error');
                return;
            }

            const nameInput = $('profile-edit-name');
            const emailInput = $('profile-edit-email');
            const avatarInput = $('profile-edit-avatar');
            const preferencesInput = $('profile-edit-preferences');

            const updates = {};
            if (nameInput?.value.trim()) updates.name = nameInput.value.trim();
            if (emailInput?.value.trim()) updates.email = emailInput.value.trim();
            if (avatarInput?.value.trim()) updates.avatar_url = avatarInput.value.trim();
            
            if (preferencesInput?.value.trim()) {
                try {
                    const prefs = JSON.parse(preferencesInput.value.trim());
                    updates.preferences = prefs;
                } catch (e) {
                    showStatusMessage('Preferences ph·∫£i l√† JSON h·ª£p l·ªá', 'error');
                    return;
                }
            }

            showLoading('ƒêang c·∫≠p nh·∫≠t h·ªì s∆°...');
            try {
                await window.profileManager.updateProfile(updates);
                closeProfileEditModal();
                showStatusMessage('ƒê√£ c·∫≠p nh·∫≠t h·ªì s∆° th√†nh c√¥ng', 'success');
            } catch (error) {
                showStatusMessage(`C·∫≠p nh·∫≠t h·ªì s∆° th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Access Gate
        function unlockInterface() {
            document.body.classList.remove('locked');
            accessGate?.classList.add('hidden');
        }

        function handleAccessAttempt() {
            if (accessInput?.value.trim() === ACCESS_CODE) {
                sessionStorage.setItem('faceswap:authorized', 'true');
                if (accessError) accessError.textContent = '';
                unlockInterface();
            } else {
                if (accessError) accessError.textContent = 'M√£ sai, vui l√≤ng th·ª≠ l·∫°i';
                if (accessInput) { accessInput.value = ''; accessInput.focus(); }
            }
        }

        function initAccessGate() {
            if (sessionStorage.getItem('faceswap:authorized') === 'true') { unlockInterface(); return; }
            document.body.classList.add('locked');
            accessGate?.classList.remove('hidden');
            accessSubmit?.addEventListener('click', handleAccessAttempt);
            accessInput?.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); handleAccessAttempt(); } });
            setTimeout(() => accessInput?.focus(), 50);
        }

        // Loading Timer
        let loadingTimerInterval = null;
        let loadingStartTime = null;

        function startLoadingTimer() {
            loadingStartTime = Date.now();
            const timerEl = $('loading-timer');
            if (!timerEl) return;
            
            if (loadingTimerInterval) clearInterval(loadingTimerInterval);
            loadingTimerInterval = setInterval(() => {
                if (!loadingStartTime) return;
                const elapsed = ((Date.now() - loadingStartTime) / 1000).toFixed(1);
                if (timerEl) timerEl.textContent = `${elapsed}s`;
            }, 100);
        }

        function stopLoadingTimer() {
            if (loadingTimerInterval) {
                clearInterval(loadingTimerInterval);
                loadingTimerInterval = null;
            }
            const timerEl = $('loading-timer');
            if (timerEl) timerEl.textContent = '0.0s';
            loadingStartTime = null;
        }

        // Logging
        function generateCurlCommand(method, fullUrl, headers, body) {
            let curl = `curl -X ${method}`;
            
            if (headers) {
                Object.entries(headers).forEach(([key, value]) => {
                    // Skip Content-Type for FormData as curl will set it automatically
                    if (body instanceof FormData && key.toLowerCase() === 'content-type') {
                        return;
                    }
                    curl += ` \\\n  -H "${key}: ${value}"`;
                });
            }
            
            curl += ` \\\n  "${fullUrl}"`;
            
            if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
                if (body instanceof FormData) {
                    // Extract actual values from FormData
                    const formEntries = [];
                    for (const [key, value] of body.entries()) {
                        if (value instanceof File) {
                            formEntries.push({ key, value: `@${value.name}`, isFile: true });
                        } else {
                            formEntries.push({ key, value: String(value), isFile: false });
                        }
                    }
                    
                    // Generate curl command with actual FormData values
                    formEntries.forEach(({ key, value, isFile }) => {
                        if (isFile) {
                            curl += ` \\\n  -F "${key}=${value}"`;
                        } else {
                            curl += ` \\\n  -F "${key}=${value}"`;
                        }
                    });
                } else if (typeof body === 'string') {
                    try {
                        const parsed = JSON.parse(body);
                        curl += ` \\\n  -d '${JSON.stringify(parsed, null, 2).replace(/'/g, "'\\''")}'`;
                    } catch {
                        curl += ` \\\n  -d '${body.replace(/'/g, "'\\''")}'`;
                    }
                } else if (body && typeof body === 'object') {
                    curl += ` \\\n  -d '${JSON.stringify(body, null, 2).replace(/'/g, "'\\''")}'`;
                }
            }
            
            return curl;
        }

        function logApiCall({ label, method, url, status = 'info', payload, duration, headers, body, fullUrl }) {
            if (!apiLogList || !['POST', 'PUT', 'DELETE', 'GET'].includes((method || '').toUpperCase())) return;
            
            const entry = document.createElement('div');
            entry.className = `api-log-entry log-${status}`;
            const durationText = duration ? formatDuration(duration) : '';
            const durationHtml = durationText ? `<span class="api-log-timing">‚è±Ô∏è ${durationText}</span>` : '';
            
            const displayUrl = fullUrl || (url.startsWith('http') ? url : `${WORKER_URL}${url.startsWith('/') ? url : '/' + url}`);
            // Extract just the path without query params
            let displayPath = url;
            if (fullUrl) {
                try {
                    const urlObj = new URL(fullUrl);
                    displayPath = urlObj.pathname;
                } catch (e) {
                    // If URL parsing fails, try to remove query string manually
                    displayPath = url.split('?')[0];
                }
            } else {
                displayPath = url.split('?')[0];
            }
            
            const statusText = status === 'success' ? 'SUCCESS' : status === 'error' ? 'ERROR' : status.toUpperCase();
            const statusColor = status === 'success' ? 'var(--success)' : status === 'error' ? 'var(--danger)' : 'var(--text-secondary)';
            
            let htmlParts = [
                `<span class="api-log-method">${method}</span> <span class="api-log-url">${displayPath}</span> <span style="color: ${statusColor}; font-weight: 600;">${statusText}</span>${durationHtml}`
            ];
            
            // Only show response payload for non-GET requests
            if (payload && method.toUpperCase() !== 'GET') {
                htmlParts.push(`<div style="margin-top: 6px; font-size: 11px; background: rgba(0,0,0,0.03); padding: 8px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;"><strong>Response:</strong><pre style="margin: 0; padding: 0;">${escapeHtml(JSON.stringify(payload, null, 2))}</pre></div>`);
            }
            
            if (method && displayUrl) {
                const curlCommand = generateCurlCommand(method, displayUrl, headers, body);
                const curlEscaped = escapeHtml(curlCommand);
                htmlParts.push(`<div style="margin-top: 8px; position: relative; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 4px;">
                    <button class="api-log-copy-btn" data-curl="${curlEscaped.replace(/"/g, '&quot;')}">Copy</button>
                    <pre style="overflow-x: auto; font-size: 11px; white-space: pre-wrap; word-wrap: break-word; word-break: break-all; margin: 0; padding-right: 60px;">${curlEscaped}</pre>
                </div>`);
            }
            
            entry.innerHTML = htmlParts.join('');
            
            // Attach copy button handler after DOM is created
            const copyBtn = entry.querySelector('.api-log-copy-btn');
            if (copyBtn) {
                const curlText = copyBtn.getAttribute('data-curl');
                copyBtn.onclick = function() {
                    navigator.clipboard.writeText(curlText).then(() => {
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.background = 'var(--success)';
                        setTimeout(() => {
                            copyBtn.textContent = 'Copy';
                            copyBtn.style.background = 'var(--accent)';
                        }, 2000);
                    }).catch(err => {
                        copyBtn.textContent = 'Error';
                        setTimeout(() => {
                            copyBtn.textContent = 'Copy';
                        }, 2000);
                    });
                };
            }
            
            apiLogList.prepend(entry);
            while (apiLogList.childElementCount > MAX_LOG_ENTRIES) apiLogList.removeChild(apiLogList.lastElementChild);
        }

        function formatDuration(ms) {
            const seconds = (ms / 1000).toFixed(1);
            return `${seconds}s`;
        }

        function clearApiLogs() { if (apiLogList) apiLogList.innerHTML = ''; }

        function toggleLogPanel() {
            const appLayout = document.querySelector('.app-layout');
            const logPanel = document.querySelector('.log-panel');
            const isHidden = appLayout?.classList.contains('log-hidden');
            if (isHidden) {
                appLayout.classList.remove('log-hidden');
                if (logPanel) { logPanel.style.display = 'flex'; setTimeout(() => { logPanel.style.opacity = '1'; logPanel.style.transform = 'translateX(0)'; }, 10); }
            } else {
                if (logPanel) { logPanel.style.opacity = '0'; logPanel.style.transform = 'translateX(20px)'; }
                setTimeout(() => appLayout?.classList.add('log-hidden'), 300);
            }
        }

        function escapeHtml(str) {
            return String(str ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        // Fetch prompt_json for a preset from backend
        async function fetchPresetPromptJson(presetId) {
            if (!presetId) return null;
            try {
                const response = await fetch(`${WORKER_URL}/presets/${encodeURIComponent(presetId)}`, {
                    method: 'GET',
                    headers: buildHeaders()
                });
                if (!response.ok) return null;
                const data = await response.json();
                return data?.data?.prompt_json || null;
            } catch (error) {
                console.error('[fetchPresetPromptJson] Error:', error);
                return null;
            }
        }

        // Gallery Functions
        const loadingGalleries = new Set();
        async function loadGallery(type) {
            const config = galleries[type];
            const loadKey = type;

            // Prevent duplicate simultaneous calls - check and add atomically
            if (loadingGalleries.has(loadKey)) {
                return;
            }
            loadingGalleries.add(loadKey);
            
            let startTime = null;
            let errorLogged = false;
            const params = new URLSearchParams();
            try {
                if ((type === 'selfie' || type === 'results') && !window.profileManager?.currentProfile) {
                    config.state.items = []; config.state.page = 1; renderGallery(type);
                    loadingGalleries.delete(loadKey);
                    return;
                }
                let url = `${WORKER_URL}${config.endpoints.list}`;
                if ((type === 'selfie' || type === 'results') && window.profileManager.currentProfile) {
                    const profileId = window.profileManager.currentProfile.id;
                    params.append('profile_id', profileId);
                }
                // Gender filter removed - metadata is in R2 path, not DB
                if (params.toString()) url += `?${params.toString()}`;
                startTime = Date.now();
                const response = await fetch(url, { headers: buildHeaders() });
                const duration = Date.now() - startTime;
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    errorLogged = true;
                    logApiCall({ label: `T·∫£i ${config.logName}`, method: 'GET', url: `${config.endpoints.list}${params.toString() ? '?' + params.toString() : ''}`, fullUrl: url, status: 'error', duration, payload: errorData });
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                let items = data[config.responseKey] || data.data?.[config.responseKey] || [];
                
                // Only log success if we actually got data or it's a valid empty response
                const status = (response.ok && data !== null && typeof data === 'object') ? 'success' : 'error';
                logApiCall({ label: `T·∫£i ${config.logName}`, method: 'GET', url: `${config.endpoints.list}${params.toString() ? '?' + params.toString() : ''}`, fullUrl: url, status, duration, payload: data });
                
                // For presets, map thumbnails response to preset format - prefer Lottie, fallback to WebP
                if (type === 'preset') {
                    const presetItems = [];
                    items.forEach((item) => {
                        const presetId = item.preset_id;
                        // Prefer Lottie if available, otherwise use WebP
                        let thumbnailUrl = null;
                        let format = null;
                        
                        if (item.thumbnail_url_4x_lottie) {
                            thumbnailUrl = item.thumbnail_url_4x_lottie;
                            format = 'lottie';
                        } else if (item.thumbnail_url_4x_lottie_avif) {
                            thumbnailUrl = item.thumbnail_url_4x_lottie_avif;
                            format = 'lottie_avif';
                        } else if (item.thumbnail_url_4x && !item.thumbnail_url_4x.toLowerCase().endsWith('.json')) {
                            thumbnailUrl = item.thumbnail_url_4x;
                            format = 'webp';
                        }
                        
                        if (thumbnailUrl) {
                            presetItems.push({
                                id: presetId,
                                image_url: thumbnailUrl,
                                preset_id: presetId,
                                thumbnail_url_4x: thumbnailUrl,
                                thumbnail_url_4x_lottie: item.thumbnail_url_4x_lottie,
                                thumbnail_url_4x_lottie_avif: item.thumbnail_url_4x_lottie_avif,
                                format: format
                            });
                        }
                    });
                    items = presetItems;
                }
                
                // Normalize field names: map selfie_url/preset_url/result_url to image_url for backward compatibility
                config.state.items = items.map((item) => {
                    const normalized = {
                        ...item,
                        image_url: item.selfie_url || item.preset_url || item.result_url || item.image_url
                    };
                    // Ensure result_url is preserved for results type
                    if (type === 'results' && item.result_url && !normalized.result_url) {
                        normalized.result_url = item.result_url;
                    }
                    return normalized;
                });
                config.state.page = 1;

                // Extract categories for presets
                if (type === 'preset') {
                    const categories = new Set();
                    const parentCategories = new Set();
                    config.state.items.forEach(item => {
                        const category = extractCategoryFromPresetId(item.preset_id || item.id || '');
                        const parentCategory = extractParentCategoryFromPresetId(item.preset_id || item.id || '');
                        if (category) categories.add(category);
                        if (parentCategory) parentCategories.add(parentCategory);
                    });
                    config.state.categories = Array.from(categories).sort();
                    config.state.parentCategories = Array.from(parentCategories).sort();
                    
                    // Load saved parent category selection from localStorage
                    const savedParentCategory = localStorage.getItem('preset:selectedParentCategory');
                    if (savedParentCategory && (config.state.parentCategories.includes(savedParentCategory) || savedParentCategory === 'All' || savedParentCategory === 'Other')) {
                        config.state.selectedParentCategory = savedParentCategory;
                    } else {
                        config.state.selectedParentCategory = 'All';
                        localStorage.setItem('preset:selectedParentCategory', 'All');
                    }
                    
                    // Load saved category selection from localStorage
                    const savedCategory = localStorage.getItem('preset:selectedCategory');
                    if (savedCategory && (config.state.categories.includes(savedCategory) || savedCategory === 'Other' || savedCategory === 'All')) {
                        config.state.selectedCategory = savedCategory;
                    } else if (!savedCategory) {
                        // Default to 'All' if no saved category exists
                        config.state.selectedCategory = 'All';
                        localStorage.setItem('preset:selectedCategory', 'All');
                    } else {
                        // Saved category doesn't exist in current categories, use 'All'
                        config.state.selectedCategory = 'All';
                        localStorage.setItem('preset:selectedCategory', 'All');
                    }
                    
                    // Update parent category dropdown
                    const parentSelect = $('preset-parent-category-select');
                    if (parentSelect) {
                        parentSelect.value = config.state.selectedParentCategory;
                    }
                    
                    updatePresetCategoryDropdown();
                    
                    // Apply saved filters after dropdowns are updated
                    if (config.state.selectedCategory || config.state.selectedParentCategory !== 'All') {
                        renderGallery('preset');
                    }
                }

                // Update preset counter in header
                if (type === 'preset') {
                    const presetTitle = $('preset-title');
                    if (presetTitle) {
                        const items = config.state.items;
                        const searchQuery = config.state.searchQuery;
                        const displayItems = searchQuery ? config.state.filteredItems || items : items;
                        const totalCount = displayItems.length;
                        const webpCount = displayItems.filter(item => item.format === 'webp' || (!item.format && !item.thumbnail_url_4x?.toLowerCase().endsWith('.json'))).length;
                        const lottieCount = displayItems.filter(item => item.format === 'lottie' || item.format === 'lottie_avif' || item.thumbnail_url_4x?.toLowerCase().endsWith('.json')).length;

                        if (searchQuery) {
                            presetTitle.textContent = `M·∫´u (Presets) ${totalCount} k·∫øt qu·∫£ (${webpCount} webp, ${lottieCount} lottie)`;
                        } else {
                            presetTitle.textContent = `M·∫´u (Presets) total ${totalCount} (${webpCount} webp, ${lottieCount} lottie)`;
                        }
                    }
                }

                renderGallery(type);
            } catch (error) {
                // Only log error if it wasn't already logged (e.g., network errors, JSON parse errors)
                if (!errorLogged) {
                    const duration = startTime ? Date.now() - startTime : 0;
                    const errorUrl = `${WORKER_URL}${config.endpoints.list}${params.toString() ? '?' + params.toString() : ''}`;
                    logApiCall({ label: `T·∫£i ${config.logName}`, method: 'GET', url: config.endpoints.list, fullUrl: errorUrl, status: 'error', duration });
                }
                config.state.items = []; config.state.page = 1; renderGallery(type);
            } finally {
                loadingGalleries.delete(loadKey);
            }
        }

        function extractParentCategoryFromPresetId(presetId) {
            if (!presetId) return 'Other';
            const parts = presetId.split('_');
            if (parts.length < 1) return 'Other';
            const firstPart = parts[0].toLowerCase();
            if (firstPart === 'fs' || firstPart === 'ft') {
                return firstPart;
            }
            return 'Other';
        }

        function extractCategoryFromPresetId(presetId) {
            if (!presetId) return 'Other';
            const parts = presetId.split('_');
            if (parts.length < 3) return 'Other';
            const lastPart = parts[parts.length - 1];
            const hasExtension = lastPart.includes('.');
            if (hasExtension && parts.length >= 4) {
                return parts.slice(1, parts.length - 2).join('_');
            } else if (parts.length >= 3) {
                return parts[1];
            }
            return 'Other';
        }

        function updatePresetCategoryDropdown() {
            const select = $('preset-category-select');
            if (!select) return;
            const allCategories = galleries.preset.state.categories || [];
            const selectedParentCategory = galleries.preset.state.selectedParentCategory || 'All';
            
            // Filter categories by selected parent category
            let categories = [];
            if (selectedParentCategory === 'All') {
                categories = allCategories;
            } else {
                // Only show categories that belong to items with the selected parent category
                const filteredItems = galleries.preset.state.items.filter(item => {
                    const parentCategory = extractParentCategoryFromPresetId(item.preset_id || item.id || '');
                    return parentCategory === selectedParentCategory;
                });
                const categorySet = new Set();
                filteredItems.forEach(item => {
                    const category = extractCategoryFromPresetId(item.preset_id || item.id || '');
                    if (category) categorySet.add(category);
                });
                categories = Array.from(categorySet).sort();
            }
            
            const savedCategory = localStorage.getItem('preset:selectedCategory') || 'All';
            const currentStateCategory = galleries.preset.state.selectedCategory;
            const categoryToUse = currentStateCategory || savedCategory;
            
            select.innerHTML = '';
            const allOption = document.createElement('option');
            allOption.value = 'All';
            allOption.textContent = 'All';
            select.appendChild(allOption);
            
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                select.appendChild(option);
            });
            const otherOption = document.createElement('option');
            otherOption.value = 'Other';
            otherOption.textContent = 'Other';
            select.appendChild(otherOption);
            
            // Set the value and update state
            select.value = categoryToUse;
            galleries.preset.state.selectedCategory = categoryToUse;
            
            // Save to localStorage if different
            if (localStorage.getItem('preset:selectedCategory') !== categoryToUse) {
                localStorage.setItem('preset:selectedCategory', categoryToUse);
            }
        }

        function handlePresetParentCategoryChange(parentCategory) {
            galleries.preset.state.selectedParentCategory = parentCategory;
            localStorage.setItem('preset:selectedParentCategory', parentCategory);
            galleries.preset.state.page = 1;
            
            // Determine which category to select
            let categoryToSelect = 'All';
            if (parentCategory !== 'All') {
                // Get available categories for this parent category
                const filteredItems = galleries.preset.state.items.filter(item => {
                    const parentCategoryFromItem = extractParentCategoryFromPresetId(item.preset_id || item.id || '');
                    return parentCategoryFromItem === parentCategory;
                });
                const categorySet = new Set();
                filteredItems.forEach(item => {
                    const category = extractCategoryFromPresetId(item.preset_id || item.id || '');
                    if (category) categorySet.add(category);
                });
                const categories = Array.from(categorySet).sort();
                // Auto-select first available category
                categoryToSelect = categories.length > 0 ? categories[0] : 'All';
            }
            
            // Set category in state before updating dropdown
            galleries.preset.state.selectedCategory = categoryToSelect;
            localStorage.setItem('preset:selectedCategory', categoryToSelect);
            
            // Update dropdown (will use the category we just set)
            updatePresetCategoryDropdown();
            
            renderGallery('preset');
        }

        function handlePresetCategoryChange(category) {
            galleries.preset.state.selectedCategory = category;
            localStorage.setItem('preset:selectedCategory', category);
            galleries.preset.state.page = 1;
            renderGallery('preset');
        }

        function renderGallery(type) {
            const config = galleries[type];
            let { items, page, selected } = config.state;
            const { gallery, pagination, prevBtn, nextBtn } = config.elements;
            if (!gallery) return;

            // Apply search filter FIRST on full list (independent of category filters)
            // Search matches anywhere in the text (substring matching, not just beginning or exact)
            if (type === 'preset' && config.state.searchQuery) {
                const query = String(config.state.searchQuery).toLowerCase().trim();
                if (query) {
                    // Normalize query: remove special chars for flexible matching
                    const queryNormalized = query.replace(/[_\-\s\.]/g, '');
                    
                    items = items.filter(item => {
                        const presetId = String(item.preset_id || item.id || '').toLowerCase();
                        const id = String(item.id || '').toLowerCase();
                        const imageUrl = String(item.image_url || item.thumbnail_url_4x || '').toLowerCase();
                        
                        // Normalize strings for loose matching (remove spaces, underscores, hyphens, dots)
                        const presetIdNormalized = presetId.replace(/[_\-\s\.]/g, '');
                        const idNormalized = id.replace(/[_\-\s\.]/g, '');
                        const imageUrlNormalized = imageUrl.replace(/[_\-\s\.]/g, '');
                        
                        // Primary check: query as substring anywhere in the text (not just beginning)
                        if (presetId.includes(query) || id.includes(query) || imageUrl.includes(query)) {
                            return true;
                        }
                        
                        // Normalized matching: match without special characters (allows matching "abc_def" with "abc def")
                        if (queryNormalized && (
                            presetIdNormalized.includes(queryNormalized) || 
                            idNormalized.includes(queryNormalized) ||
                            imageUrlNormalized.includes(queryNormalized)
                        )) {
                            return true;
                        }
                        
                        return false;
                    });
                } else {
                    // Clear search query if empty
                    config.state.searchQuery = '';
                }
            }

            // Apply parent category filter for presets (fs/ft/Other) - after search
            if (type === 'preset' && config.state.selectedParentCategory && config.state.selectedParentCategory !== 'All') {
                items = items.filter(item => {
                    const parentCategory = extractParentCategoryFromPresetId(item.preset_id || item.id || '');
                    return parentCategory === config.state.selectedParentCategory;
                });
            }
            
            // Apply category filter for presets - after search
            if (type === 'preset' && config.state.selectedCategory && config.state.selectedCategory !== 'All') {
                items = items.filter(item => {
                    const category = extractCategoryFromPresetId(item.preset_id || item.id || '');
                    return category === config.state.selectedCategory;
                });
            }
            
            // Always set filteredItems to current items (filtered or not)
            config.state.filteredItems = items;

            if (!items.length) {
                gallery.style.display = 'none';
                if (pagination) pagination.style.display = 'none';
                if (type === 'results') {
                    gallery.innerHTML = '<div style="text-align:center;padding:40px;color:#999;">Ch∆∞a c√≥ k·∫øt qu·∫£ n√†o</div>';
                    gallery.style.display = 'block';
                } else if (type === 'preset' && config.state.searchQuery) {
                    gallery.innerHTML = '<div style="text-align:center;padding:40px;color:#999;">Kh√¥ng t√¨m th·∫•y preset n√†o</div>';
                    gallery.style.display = 'block';
                }
                return;
            }

            gallery.style.display = 'grid';
            if (pagination) pagination.style.display = 'flex';

            const totalPages = Math.ceil(items.length / ITEMS_PER_PAGE);
            config.state.page = Math.min(page, Math.max(1, totalPages));
            const startIndex = (config.state.page - 1) * ITEMS_PER_PAGE;
            const pageItems = items.slice(startIndex, startIndex + ITEMS_PER_PAGE);

            if (type === 'results') {
                gallery.innerHTML = pageItems.map((item, index) => {
                    const globalIndex = startIndex + index;
                    const imageUrl = item.result_url || item.image_url || '';
                    return `<div class="gallery-item" data-item-id="${item.id}" draggable="true" ondragstart="handleResultDrag(event, '${item.id.replace(/'/g, "\\'")}', '${imageUrl.replace(/'/g, "\\'")}')">
                        <img src="${imageUrl}" alt="" loading="lazy" onclick="openLightbox(${globalIndex}); displayResultInPreview('${imageUrl.replace(/'/g, "\\'")}');" draggable="false">
                        <button class="gallery-delete-btn" onclick="deleteItem('${type}', '${item.id}', event)">√ó</button>
                    </div>`;
                }).join('');
            } else {
                gallery.innerHTML = pageItems.map(item => {
                    const isSelected = type === 'selfie' && Array.isArray(selected) 
                        ? selected.some(s => s.id === item.id)
                        : selected?.id === item.id;
                    // Add action badge for selfies
                    const actionBadge = type === 'selfie' && item.action 
                        ? `<span class="gallery-action-badge action-${item.action.toLowerCase()}">${item.action.toLowerCase() === '4k' ? '4K' : item.action}</span>`
                        : '';
                    
                    // Display both WebP and Lottie
                    let mediaElement = '';
                    const thumbnailUrl = item.thumbnail_url_4x || item.image_url;
                    const isLottie = thumbnailUrl && (thumbnailUrl.toLowerCase().endsWith('.json') || item.format === 'lottie' || item.format === 'lottie_avif');
                    
                    if (isLottie) {
                        const lottieId = `lottie-${item.id.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        mediaElement = `<div id="${lottieId}" style="width: 100%; height: 100%; background: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center;"></div>`;
                        setTimeout(() => {
                            if (typeof lottie !== 'undefined' && thumbnailUrl) {
                                try {
                                    const container = document.getElementById(lottieId);
                                    if (!container) return;
                                    
                                    // Destroy any existing animation in this container
                                    if (container.lottieInstance) {
                                        container.lottieInstance.destroy();
                                        container.lottieInstance = null;
                                    }
                                    
                                    // Clear container content
                                    container.innerHTML = '';
                                    
                                    const anim = lottie.loadAnimation({
                                        container: container,
                                        renderer: 'svg',
                                        loop: false,
                                        autoplay: true,
                                        path: thumbnailUrl
                                    });
                                    
                                    container.lottieInstance = anim;
                                } catch (e) {
                                }
                            }
                        }, 100);
                    } else if (thumbnailUrl) {
                        mediaElement = `<img src="${thumbnailUrl}" alt="" loading="lazy">`;
                    } else {
                        mediaElement = `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--text-muted); font-size: 11px;">No thumbnail</div>`;
                    }
                    
                    if (type === 'preset') {
                        // For presets, open lightbox first, then allow selection from lightbox
                        // Use preset_id to find all formats of the same preset
                        return `<div class="gallery-item ${isSelected ? 'selected' : ''}" onclick="openPresetLightbox('${item.preset_id}')" data-item-id="${item.id}" data-preset-id="${item.preset_id}">
                            ${mediaElement}
                            ${actionBadge}
                            <button class="gallery-delete-btn" onclick="deleteItem('${type}', '${item.id}', event)">√ó</button>
                        </div>`;
                    } else {
                        // For selfies and other types, use existing selection logic (direct selection, no lightbox)
                        return `<div class="gallery-item ${isSelected ? 'selected' : ''}" onclick="handleSelect('${type}', '${item.id}', event)" data-item-id="${item.id}">
                            ${mediaElement}
                            ${actionBadge}
                            <button class="gallery-delete-btn" onclick="deleteItem('${type}', '${item.id}', event)">√ó</button>
                        </div>`;
                    }
                }).join('');
            }

            if (prevBtn) prevBtn.disabled = config.state.page === 1;
            if (nextBtn) nextBtn.disabled = config.state.page === totalPages;

            // Update preset title with search results count
            if (type === 'preset') {
                const presetTitle = $('preset-title');
                if (presetTitle) {
                    const allItems = galleries.preset.state.items;
                    const searchQuery = galleries.preset.state.searchQuery;
                    const selectedCategory = galleries.preset.state.selectedCategory;
                    const selectedParentCategory = galleries.preset.state.selectedParentCategory;
                    const hasFilter = searchQuery || selectedCategory || (selectedParentCategory && selectedParentCategory !== 'All');
                    const displayItems = hasFilter ? items : allItems;
                    const totalCount = displayItems.length;
                    const webpCount = displayItems.filter(item => item.format === 'webp' || (!item.format && !item.thumbnail_url_4x?.toLowerCase().endsWith('.json'))).length;
                    const lottieCount = displayItems.filter(item => item.format === 'lottie' || item.format === 'lottie_avif' || item.thumbnail_url_4x?.toLowerCase().endsWith('.json')).length;

                    if (hasFilter) {
                        presetTitle.textContent = `M·∫´u (Presets) ${totalCount} k·∫øt qu·∫£ (${webpCount} webp, ${lottieCount} lottie)`;
                    } else {
                        presetTitle.textContent = `M·∫´u (Presets) total ${totalCount} (${webpCount} webp, ${lottieCount} lottie)`;
                    }
                }
            }

            const numbersContainer = $(type + '-dots');
            if (numbersContainer && totalPages > 1) {
                numbersContainer.innerHTML = '';
                const currentPage = config.state.page;
                const maxVisible = 7;
                
                if (totalPages <= maxVisible) {
                    // Show all pages if total is small
                    for (let i = 1; i <= totalPages; i++) {
                        const numberBtn = document.createElement('button');
                        numberBtn.className = 'pagination-number' + (i === currentPage ? ' active' : '');
                        numberBtn.textContent = i.toString();
                        numberBtn.onclick = () => { config.state.page = i; renderGallery(type); };
                        numbersContainer.appendChild(numberBtn);
                    }
                } else {
                    // Smart pagination with ellipsis
                    const showEllipsis = (text) => {
                        const ellipsis = document.createElement('span');
                        ellipsis.textContent = text;
                        ellipsis.style.cssText = 'padding: 0 4px; color: var(--text-secondary); user-select: none;';
                        numbersContainer.appendChild(ellipsis);
                    };
                    
                    // Always show first page
                    const firstBtn = document.createElement('button');
                    firstBtn.className = 'pagination-number' + (currentPage === 1 ? ' active' : '');
                    firstBtn.textContent = '1';
                    firstBtn.onclick = () => { config.state.page = 1; renderGallery(type); };
                    numbersContainer.appendChild(firstBtn);
                    
                    if (currentPage > 3) {
                        showEllipsis('...');
                    }
                    
                    // Show pages around current
                    const start = Math.max(2, currentPage - 1);
                    const end = Math.min(totalPages - 1, currentPage + 1);
                    
                    for (let i = start; i <= end; i++) {
                        if (i === 1 || i === totalPages) continue;
                        const numberBtn = document.createElement('button');
                        numberBtn.className = 'pagination-number' + (i === currentPage ? ' active' : '');
                        numberBtn.textContent = i.toString();
                        numberBtn.onclick = () => { config.state.page = i; renderGallery(type); };
                        numbersContainer.appendChild(numberBtn);
                    }
                    
                    if (currentPage < totalPages - 2) {
                        showEllipsis('...');
                    }
                    
                    // Always show last page
                    const lastBtn = document.createElement('button');
                    lastBtn.className = 'pagination-number' + (currentPage === totalPages ? ' active' : '');
                    lastBtn.textContent = totalPages.toString();
                    lastBtn.onclick = () => { config.state.page = totalPages; renderGallery(type); };
                    numbersContainer.appendChild(lastBtn);
                }
            }

            if (type === 'results') updateResultsCount();
        }

        function changePage(type, delta) {
            const config = galleries[type];
            // Use filtered items if available, otherwise use all items
            const itemsToUse = config.state.filteredItems && config.state.filteredItems.length > 0 
                ? config.state.filteredItems 
                : config.state.items;
            const totalPages = Math.ceil(itemsToUse.length / ITEMS_PER_PAGE) || 1;
            const newPage = config.state.page + delta;
            if (newPage >= 1 && newPage <= totalPages) {
                config.state.page = newPage;
                renderGallery(type);
            }
        }

        function handleSelect(type, itemId, event) {
            event?.stopPropagation();
            const config = galleries[type];
            const item = config.state.items.find(e => e.id === itemId);
            if (item) setSelectedItem(type, item, { showMessage: true });
        }

        function setSelectedItem(type, item, options = {}) {
            const config = galleries[type];
            if (type === 'selfie') {
                // Support multiple selfie selection (up to 2 for wedding faceswap)
                const selected = config.state.selected || [];
                const itemIndex = selected.findIndex(s => s.id === item.id);
                if (itemIndex >= 0) {
                    // Deselect if already selected
                    selected.splice(itemIndex, 1);
                } else {
                    // Add to selection (max 2)
                    if (selected.length < 2) {
                        selected.push(item);
                    } else {
                        // Replace the first one if already at max
                        selected[0] = item;
                    }
                }
                config.state.selected = selected;
            } else {
                config.state.selected = item || null;
            }
            updatePreview(type);
            renderGallery(type);
            updateGenerateButton();
            updateImageOperationButtons();
            
            // Clear result preview when preset or selfie is selected
            if ((type === 'preset' || type === 'selfie') && item) {
                clearResultPreview();
            }
            
            if (options.showMessage && item) showStatusMessage(config.labels.selectSuccess, 'success');
        }

        function clearResultPreview() {
            const resultPreview = $('result-preview');
            if (resultPreview) {
                resultPreview.innerHTML = `<div class="preview-empty">
                    <div class="preview-empty-icon">‚ú®</div>
                    <div class="preview-empty-text">K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y (Result will appear here)</div>
                </div>`;
            }
        }

        function updatePreview(type) {
            const config = galleries[type];
            const { selected } = config.state;
            const preview = config.elements.preview;
            if (!preview) return;

            const clearBtn = $(type + '-clear-btn');
            
            // Update selfie preview label with action type
            if (type === 'selfie') {
                const labelEl = document.querySelector('#selfie-card .preview-label');
                if (labelEl) {
                    if (Array.isArray(selected) && selected.length > 0) {
                        const actions = selected.map(s => {
                            const action = s.action?.toLowerCase() || 'faceswap';
                            if (action === '4k') return '4K';
                            if (action === 'faceswap') return 'Faceswap';
                            if (action === 'wedding') return 'Wedding';
                            return 'Default';
                        });
                        const uniqueActions = [...new Set(actions)];
                        const actionText = uniqueActions.length === 1 
                            ? uniqueActions[0] 
                            : uniqueActions.join(', ');
                        const maxText = selected[0]?.action?.toLowerCase() === 'wedding' 
                            ? ' - T·ªëi ƒëa 2 cho Wedding'
                            : selected[0]?.action?.toLowerCase() === 'faceswap'
                            ? ' - T·ªëi ƒëa 8 cho Faceswap'
                            : selected[0]?.action?.toLowerCase() === '4k'
                            ? ' - T·ªëi ƒëa 1 cho 4K'
                            : ' - T·ªëi ƒëa 1';
                        labelEl.textContent = `·∫¢nh T·ª± S∆∞·ªõng (Selfie) - ${actionText}${maxText}`;
                    } else if (selected && !Array.isArray(selected)) {
                        const action = selected.action?.toLowerCase() || 'faceswap';
                        let actionText = 'Faceswap';
                        let maxText = ' - T·ªëi ƒëa 8 cho Faceswap';
                        if (action === '4k') {
                            actionText = '4K';
                            maxText = ' - T·ªëi ƒëa 1 cho 4K';
                        } else if (action === 'faceswap') {
                            actionText = 'Faceswap';
                            maxText = ' - T·ªëi ƒëa 8 cho Faceswap';
                        } else if (action === 'wedding') {
                            actionText = 'Wedding';
                            maxText = ' - T·ªëi ƒëa 2 cho Wedding';
                        } else {
                            actionText = 'Default';
                            maxText = ' - T·ªëi ƒëa 1';
                        }
                        labelEl.textContent = `·∫¢nh T·ª± S∆∞·ªõng (Selfie) - ${actionText}${maxText}`;
                    } else {
                        labelEl.textContent = '·∫¢nh T·ª± S∆∞·ªõng (Selfie) - T·ªëi ƒëa 2 cho Wedding';
                    }
                }
            }
            
            if (type === 'selfie' && Array.isArray(selected)) {
                // Handle multiple selfie selection
                if (selected.length === 0) {
                    preview.innerHTML = `<div class="preview-empty"><div class="preview-empty-icon">üì∑</div><div class="preview-empty-text">Ch·ªçn t·ª´ ·∫£nh t·ª± s∆∞·ªõng (Select from selfies)</div></div>`;
                    if (clearBtn) clearBtn.style.display = 'none';
                    return;
                }
                // Display both selfies side by side
                const imagesHtml = selected.map((item, index) => {
                    const imageUrl = item.image_url || item.result_url || '';
                    const action = item.action?.toLowerCase() || 'faceswap';
                    const actionBadge = `<span class="preview-action-badge action-${action}">${action === '4k' ? '4K' : action}</span>`;
                    return `<div style="flex: 1; padding: 4px; position: relative;"><img src="${imageUrl}" alt="Selfie ${index + 1}" style="width: 100%; height: 100%; object-fit: contain; cursor: pointer; border: 2px solid #4CAF50; border-radius: 4px;" onclick="openPreviewLightbox('selfie', ${index})">${actionBadge}</div>`;
                }).join('');
                preview.innerHTML = `<div style="display: flex; gap: 8px; height: 100%;">${imagesHtml}</div>`;
                if (clearBtn) clearBtn.style.display = 'block';
                return;
            }
            
            if (!selected) {
                const emptyText = type === 'preset' ? 'Ch·ªçn t·ª´ m·∫´u (Select from presets)' : type === 'selfie' ? 'Ch·ªçn t·ª´ ·∫£nh t·ª± s∆∞·ªõng (Select from selfies)' : 'K·∫øt qu·∫£ s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y (Result will appear here)';
                preview.innerHTML = `<div class="preview-empty"><div class="preview-empty-icon">${type === 'result' ? '‚ú®' : 'üì∑'}</div><div class="preview-empty-text">${emptyText}</div></div>`;
                if (clearBtn) clearBtn.style.display = 'none';
                return;
            }
            const imageUrl = selected.image_url || selected.result_url || '';
            let mediaElement = '';
            
            const thumbnailUrl = selected.thumbnail_url_4x || imageUrl;
            const urlLower = thumbnailUrl ? thumbnailUrl.toLowerCase() : '';
            const isLottie = urlLower.endsWith('.json') || 
                           urlLower.includes('lottie') || 
                           selected.format === 'lottie' || 
                           selected.format === 'lottie_avif';
            
            if (isLottie) {
                const lottiePreviewId = `lottie-preview-${(selected.preset_id || selected.id || '').replace(/[^a-zA-Z0-9]/g, '-')}`;
                mediaElement = `<div id="${lottiePreviewId}" style="width: 100%; height: 100%; min-height: 200px; display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); border-radius: 4px;"></div>`;
                setTimeout(() => {
                    if (typeof lottie !== 'undefined' && thumbnailUrl) {
                        try {
                            const container = document.getElementById(lottiePreviewId);
                            if (!container) return;
                            
                            // Destroy any existing animation in this container
                            if (container.lottieInstance) {
                                container.lottieInstance.destroy();
                                container.lottieInstance = null;
                            }
                            
                            // Clear container content
                            container.innerHTML = '';
                            
                            const anim = lottie.loadAnimation({
                                container: container,
                                renderer: 'svg',
                                loop: false,
                                autoplay: true,
                                path: thumbnailUrl
                            });
                            
                            container.lottieInstance = anim;
                        } catch (e) {
                        }
                    }
                }, 100);
            } else if (thumbnailUrl) {
                mediaElement = `<img src="${thumbnailUrl}" alt="" style="cursor: pointer; max-width: 100%; max-height: 100%; object-fit: contain; display: block;" onclick="openPreviewLightbox('${type}')">`;
            } else {
                mediaElement = `<div style="display: flex; align-items: center; justify-content: center; min-height: 200px; height: 100%; color: var(--text-muted);">No thumbnail available</div>`;
            }
            
            const action = selected.action?.toLowerCase() || 'faceswap';
            const actionBadge = type === 'selfie' && selected.action 
                ? `<span class="preview-action-badge action-${action}">${action === '4k' ? '4K' : action}</span>`
                : '';
            
            preview.innerHTML = `<div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">${mediaElement}${actionBadge}</div>`;
            if (clearBtn) clearBtn.style.display = 'block';
        }

        function updateGenerateButton() {
            const hasPreset = !!galleries.preset.state.selected;
            const selfieSelected = galleries.selfie.state.selected;
            const hasSelfie = selfieSelected && (Array.isArray(selfieSelected) ? selfieSelected.length > 0 : !!selfieSelected);
            const additionalPromptInput = document.getElementById('additional-prompt');
            const hasCustomPrompt = additionalPromptInput && additionalPromptInput.value.trim() !== '';
            
            if (generateBtn) generateBtn.disabled = !(hasPreset && hasSelfie);
            // Enable merge button if: (preset AND selfie) OR (custom_prompt AND selfie)
            if (mergeBtn) mergeBtn.disabled = !((hasPreset || hasCustomPrompt) && hasSelfie);
        }

        function updateImageOperationButtons() {
            const selfieSelected = galleries.selfie.state.selected;
            const hasSelfie = selfieSelected && (Array.isArray(selfieSelected) ? selfieSelected.length > 0 : !!selfieSelected);
            const hasProfile = !!window.profileManager?.currentProfile;
            const shouldDisable = !(hasSelfie && hasProfile);
            
            const enhanceBtn = $('enhance-btn');
            const beautyBtn = $('beauty-btn');
            const filterBtn = $('filter-btn');
            const upscaleBtn = $('upscale4k-btn');
            const restoreBtn = $('restore-btn');
            const agingBtn = $('aging-btn');
            
            if (enhanceBtn) enhanceBtn.disabled = shouldDisable;
            if (beautyBtn) beautyBtn.disabled = shouldDisable;
            if (filterBtn) {
                const presetSelected = galleries.preset.state.selected;
                const hasPreset = !!presetSelected;
                filterBtn.disabled = !(hasSelfie && hasPreset && hasProfile);
            }
            if (upscaleBtn) upscaleBtn.disabled = shouldDisable;
            if (restoreBtn) restoreBtn.disabled = shouldDisable;
            if (agingBtn) agingBtn.disabled = shouldDisable;
        }

        function updateResultsCount() {
            const countEl = $('results-count');
            if (countEl) countEl.textContent = `(${galleries.results?.state?.items?.length || 0})`;
        }

        function clearSelection(type, event) {
            event?.stopPropagation();
            const config = galleries[type];
            config.state.selected = type === 'selfie' ? [] : null;
            updatePreview(type);
            renderGallery(type);
            updateGenerateButton();
            updateImageOperationButtons();
        }

        async function deleteItem(type, itemId, event) {
            event?.stopPropagation();
            const config = galleries[type];
            if (!confirm(config.labels.confirmDelete)) return;

            try {
                const startTime = Date.now();
                const deleteUrl = `${WORKER_URL}${config.endpoints.delete}/${itemId}`;
                const response = await fetch(deleteUrl, { method: 'DELETE', headers: buildHeaders() });
                const data = await response.json();
                const duration = Date.now() - startTime;
                logApiCall({ label: `X√≥a ${config.logName}`, method: 'DELETE', url: `${config.endpoints.delete}/${itemId}`, fullUrl: deleteUrl, status: response.ok ? 'success' : 'error', payload: data, duration });
                if (!response.ok) throw new Error(data.message || 'X√≥a th·∫•t b·∫°i');

                config.state.items = config.state.items.filter(item => item.id !== itemId);
                const totalPages = Math.ceil(config.state.items.length / ITEMS_PER_PAGE) || 1;
                config.state.page = Math.min(config.state.page, totalPages);
                if (type === 'selfie' && Array.isArray(config.state.selected)) {
                    config.state.selected = config.state.selected.filter(item => item.id !== itemId);
                } else if (config.state.selected?.id === itemId) {
                    config.state.selected = null;
                }

                // Update preset counter after deletion
                if (type === 'preset') {
                    const presetTitle = $('preset-title');
                    if (presetTitle) {
                        const items = config.state.items;
                        const webpCount = items.filter(item => item.thumbnail_url_4x).length;
                        presetTitle.textContent = `M·∫´u (Presets) total ${webpCount} webp`;
                    }
                }

                updatePreview(type);
                renderGallery(type);
                updateGenerateButton();
                updateImageOperationButtons();
                showStatusMessage(config.labels.deleteSuccess, 'success');
            } catch (error) {
                showStatusMessage('X√≥a th·∫•t b·∫°i', 'error');
            }
        }

        // Upload
        presetInput?.addEventListener('change', async e => {
            const files = Array.from(e.target.files || []);
            if (files.length > 0) await handleMultipleImageUpload(files, 'preset');
            e.target.value = '';
        });

        const presetSearchInput = $('preset-search-input');
        if (presetSearchInput) {
            presetSearchInput.addEventListener('input', (e) => {
                const query = String(e.target.value || '').trim();
                galleries.preset.state.searchQuery = query;
                galleries.preset.state.page = 1;
                renderGallery('preset');
            });
            
            // Also handle on change for better compatibility
            presetSearchInput.addEventListener('change', (e) => {
                const query = String(e.target.value || '').trim();
                galleries.preset.state.searchQuery = query;
                galleries.preset.state.page = 1;
                renderGallery('preset');
            });
        }

        selfieInput?.addEventListener('change', async e => {
            const files = Array.from(e.target.files || []);
            if (files.length > 0) await handleMultipleImageUpload(files, 'selfie');
            e.target.value = '';
        });

        window.handleResultDrag = function(event, itemId, imageUrl) {
            event.dataTransfer.setData('text/plain', JSON.stringify({ type: 'result', itemId, imageUrl }));
            event.dataTransfer.effectAllowed = 'copy';
        };

        async function handleResultDrop(data, type) {
            if (!data.imageUrl) {
                showStatusMessage('Kh√¥ng t√¨m th·∫•y URL h√¨nh ·∫£nh', 'error');
                return;
            }
            await uploadImageFromUrl(data.imageUrl, type);
        }

        window.handleResultDrop = handleResultDrop;

        function setupDragDrop(type) {
            const dropZone = $(type + '-drop-zone');
            if (!dropZone) return;
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => dropZone.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }, false));
            ['dragenter', 'dragover'].forEach(e => dropZone.addEventListener(e, () => dropZone.classList.add('dragover'), false));
            ['dragleave', 'drop'].forEach(e => dropZone.addEventListener(e, () => dropZone.classList.remove('dragover'), false));
            dropZone.addEventListener('drop', async e => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('dragover');
                
                const dragData = e.dataTransfer.getData('text/plain');
                if (dragData) {
                    try {
                        const data = JSON.parse(dragData);
                        if (data.type === 'result') {
                            await handleResultDrop(data, type);
                            return;
                        }
                    } catch (err) {
                    }
                }
                
                const files = Array.from(e.dataTransfer.files).filter(f => f?.type.match('image/(jpeg|jpg|png|webp)'));
                if (files.length > 0) await handleMultipleImageUpload(files, type);
            }, false);
        }

        async function handleMultipleImageUpload(files, type) {
            const config = galleries[type];
            if (!window.profileManager.currentProfile) { showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi t·∫£i l√™n h√¨nh ·∫£nh.', 'error'); return; }
            
            // Validate all files
            const validFiles = files.filter(file => {
                if (!file.type.match('image/(jpeg|jpg|png|webp)')) {
                    showStatusMessage(`Lo·∫°i t·ªáp kh√¥ng h·ª£p l·ªá: ${file.name}. Vui l√≤ng t·∫£i l√™n JPG, PNG ho·∫∑c WebP.`, 'error');
                    return false;
                }
                if (file.size > 10 * 1024 * 1024) {
                    showStatusMessage(`T·ªáp v∆∞·ª£t qu√° gi·ªõi h·∫°n 10MB: ${file.name}. Vui l√≤ng ch·ªçn t·ªáp nh·ªè h∆°n.`, 'error');
                    return false;
                }
                return true;
            });

            if (validFiles.length === 0) return;

            const dropZone = $(type + '-drop-zone');
            dropZone?.classList.add('loading');
            showLoading(`ƒêang t·∫£i l√™n ${validFiles.length} ${type === 'preset' ? 'm·∫´u' : 'selfie'}...`);

            try {
                const formData = new FormData();
                // Append all files with 'files' key (backend expects 'files' for multiple)
                for (const file of validFiles) {
                    formData.append('files', file);
                }
                formData.append('type', type);
                formData.append('profile_id', window.profileManager.currentProfile.id);
                
                if (type === 'preset') {
                    formData.append('enableVertexPrompt', 'true');
                    // Check if filter mode is enabled
                    const filterModeCheckbox = document.getElementById('preset-filter-mode');
                    const isFilterMode = filterModeCheckbox && filterModeCheckbox.checked === true;
                    
                    if (isFilterMode) {
                        formData.append('is_filter_mode', 'true');
                    }
                    
                    // Add custom prompt if user has customized it
                    const { defaultPrompt, filterPrompt } = loadCustomPrompts();
                    const currentPrompt = isFilterMode ? filterPrompt : defaultPrompt;
                    
                    // Only send custom prompt if it's different from default
                    const originalPrompt = isFilterMode ? DEFAULT_PROMPTS.FILTER : DEFAULT_PROMPTS.DEFAULT;
                    if (currentPrompt !== originalPrompt) {
                        formData.append('custom_prompt_text', currentPrompt);
                    } else if (isFilterMode) {
                    } else {
                    }
                    
                } else if (type === 'selfie') {
                    const actionSelect = document.getElementById('selfie-action-select');
                    const action = actionSelect?.value || 'faceswap';
                    formData.append('action', action);

                    // Get dimensions for all files (array in same order as files)
                    if (validFiles.length > 0) {
                        const dimensionsArray = await Promise.all(
                            validFiles.map(async (file) => {
                                try {
                                    return await getImageDimensions(file);
                                } catch (dimError) {
                                    console.warn('Failed to get image dimensions for', file.name, dimError);
                                    return null; // null indicates dimensions could not be determined
                                }
                            })
                        );
                        // Send as JSON array to preserve order with files
                        formData.append('dimensions', JSON.stringify(dimensionsArray));
                    }
                }

                const uploadUrl = `${WORKER_URL}/upload-url`;
                const startTime = Date.now();
                const response = await fetch(uploadUrl, { method: 'POST', headers: buildHeaders(), body: formData });
                const data = await response.json();
                const duration = Date.now() - startTime;

                logApiCall({ label: `T·∫£i L√™n ${config.logName} (${validFiles.length} files)`, method: 'POST', url: '/upload-url', fullUrl: uploadUrl, status: response.ok ? 'success' : 'error', payload: data, duration, body: formData });
                if (!response.ok || data.status !== 'success') {
                    const errorMsg = data.message || 'T·∫£i l√™n th·∫•t b·∫°i';
                    const error = new Error(errorMsg);
                    if (data.debug) {
                        error.debug = data.debug;
                    }
                    throw error;
                }

                // Process all results from data.data.results
                const results = data.data?.results || [];
                const successfulResults = results.filter(r => r.id && r.url) || [];
                const failedResults = results.filter(r => !r.id || !r.url) || [];

                if (successfulResults.length > 0) {
                    const newImages = successfulResults.map(result => ({
                        id: result.id,
                        image_url: result.url,
                        created_at: new Date().toISOString()
                    }));

                    // Add all new images to gallery
                    config.state.items = [...newImages, ...config.state.items.filter(e => !newImages.some(ni => ni.id === e.id))];
                    config.state.page = 1;
                    await loadGallery(type);
                    
                    // Select the first uploaded image
                    if (newImages.length > 0) {
                        setSelectedItem(type, newImages[0]);
                    }

                    const successMsg = successfulResults.length === validFiles.length 
                        ? `T·∫£i l√™n th√†nh c√¥ng ${successfulResults.length} h√¨nh ·∫£nh`
                        : `T·∫£i l√™n th√†nh c√¥ng ${successfulResults.length}/${validFiles.length} h√¨nh ·∫£nh`;
                    showStatusMessage(successMsg, 'success');
                }

                if (failedResults.length > 0) {
                    const errorMsg = `Th·∫•t b·∫°i: ${failedResults.length} h√¨nh ·∫£nh kh√¥ng th·ªÉ t·∫£i l√™n`;
                    showStatusMessage(errorMsg, 'error');
                }
            } catch (error) {
                showStatusMessage(`T·∫£i l√™n th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                dropZone?.classList.remove('loading');
                hideLoading();
            }
        }

        // Keep backward compatibility
        async function handleImageUpload(file, type) {
            await handleMultipleImageUpload([file], type);
        }

        // Face Swap & Operations
        async function generateFaceSwap() {
            const presetSelected = galleries.preset.state.selected;
            const selfieSelected = galleries.selfie.state.selected;
            const selfieArray = Array.isArray(selfieSelected) ? selfieSelected : (selfieSelected ? [selfieSelected] : []);
            if (!presetSelected || selfieArray.length === 0) { showStatusMessage('Vui l√≤ng ch·ªçn c·∫£ m·∫´u v√† √≠t nh·∫•t m·ªôt selfie tr∆∞·ªõc khi t·∫°o ƒë·ªïi m·∫∑t.', 'error'); return; }
            if (!window.profileManager?.currentProfile) { showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi t·∫°o ƒë·ªïi m·∫∑t.', 'error'); return; }

            generateBtn.disabled = true;
            generateBtn.classList.add('loading');
            showLoading('ƒêang t·∫°o ƒë·ªïi m·∫∑t...');

            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                if (!aspectRatioSelect) {
                }
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || '3:4';
                const providerSelect = document.getElementById('image-provider');
                const selectedProvider = providerSelect?.value || localStorage.getItem('faceswap:provider') || '';
                // Always prefer preset_id (filename) over URL for API calls
                const presetId = presetSelected.preset_id || presetSelected.id;
                const usePresetUrl = !presetId || presetId.startsWith('result-preset-');
                
                // Build selfie arrays (support multiple selfies for wedding faceswap)
                const selfieIds = [];
                const selfieUrls = [];
                for (const selfie of selfieArray) {
                    const useSelfieUrl = !selfie.id || selfie.id?.startsWith('result-selfie-');
                    if (useSelfieUrl) {
                        selfieUrls.push(selfie.image_url);
                    } else {
                        selfieIds.push(selfie.id);
                    }
                }
                
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                const selectedFormat = presetSelected?.format || localStorage.getItem('preset:format') || 'webp';

                const requestBody = {
                    ...(usePresetUrl
                        ? { preset_image_url: presetSelected.image_url }
                        : { preset_image_id: presetId }
                    ),
                    profile_id: window.profileManager.currentProfile.id,
                    additional_prompt: additionalPromptInput?.value.trim() || '',
                    aspect_ratio: selectedAspectRatio,
                    model: selectedModel,
                    format: selectedFormat,
                    ...(selectedProvider && { provider: selectedProvider })
                };
                
                if (selfieUrls.length > 0) {
                    requestBody.selfie_image_urls = selfieUrls;
                }
                if (selfieIds.length > 0) {
                    requestBody.selfie_ids = selfieIds;
                }

                const faceswapUrl = `${WORKER_URL}/faceswap`;
                const startTime = Date.now();
                const response = await fetch(faceswapUrl, { method: 'POST', headers: buildHeaders({ 'Content-Type': 'application/json' }), body: JSON.stringify(requestBody) });
                const data = await response.json();
                const duration = Date.now() - startTime;

                logApiCall({ label: 'T·∫°o ƒê·ªïi M·∫∑t', method: 'POST', url: '/faceswap', fullUrl: faceswapUrl, status: response.ok ? 'success' : 'error', payload: data, duration, headers: { 'Content-Type': 'application/json' }, body: requestBody });
                if (!response.ok || !data.data?.resultImageUrl) throw new Error(data.message || 'ƒê·ªïi m·∫∑t th·∫•t b·∫°i');

                // Reload results from server to ensure we have the saved result with correct profile_id
                await loadGallery('results');
                
                // Find the newly created result in the loaded items
                const loadedResults = galleries.results.state.items;
                const newResult = loadedResults.find(r => r.result_url === data.data.resultImageUrl) || 
                                 { id: data.data.id || `result-${Date.now()}`, result_url: data.data.resultImageUrl, image_url: data.data.resultImageUrl, created_at: new Date().toISOString() };
                
                displayResultInPreview(newResult.image_url);
                updateResultsCount();
                showStatusMessage('T·∫°o ƒë·ªïi m·∫∑t th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatusMessage(`T·∫°o ƒë·ªïi m·∫∑t th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                generateBtn.disabled = false;
                generateBtn.classList.remove('loading');
                hideLoading();
                updateGenerateButton();
                updateImageOperationButtons();
            }
        }

        async function downloadImage(url, filename) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const downloadUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(downloadUrl);
                return true;
            } catch (error) {
                return false;
            }
        }

        async function batchProcessTryImages() {
            if (!window.profileManager?.currentProfile) {
                showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi ch·∫°y batch.', 'error');
                return;
            }

            const batchBtn = document.getElementById('batch-try-btn');
            if (!batchBtn) return;

            await loadGallery('preset');
            const allPresets = galleries.preset.state.items || [];
            
            if (allPresets.length === 0) {
                showStatusMessage('Kh√¥ng c√≥ preset n√†o trong gallery. Vui l√≤ng t·∫£i presets tr∆∞·ªõc.', 'error');
                return;
            }

            const presetCategories = {
                'ai_avatar': { tryPath: 'ai_avatar', tryImages: ['try_1.webp', 'try_2.webp', 'try_3.webp'] },
                'ai_restore': { tryPath: 'ai_restore', tryImages: ['try_1.webp', 'try_2.webp', 'try_3.webp'] },
                'ai_enhance': { tryPath: 'ai_enhance', tryImages: ['try_1.webp', 'try_2.webp', 'try_3.webp'] },
                'ai_beauty': { tryPath: 'ai_beauty', tryImages: ['try_1.webp', 'try_2.webp', 'try_3.webp'] },
                'ai_upscale_4k': { tryPath: 'ai_upscale_4k', tryImages: ['try_1.webp', 'try_2.webp', 'try_3.webp'] }
            };

            const presetMap = new Map();
            allPresets.forEach(preset => {
                const presetId = preset.preset_id || preset.id || '';
                for (const [category, config] of Object.entries(presetCategories)) {
                    if (presetId.includes(category) || presetId.toLowerCase().includes(category.replace('_', ''))) {
                        if (!presetMap.has(category)) {
                            presetMap.set(category, []);
                        }
                        presetMap.get(category).push(preset);
                    }
                }
            });

            const totalCombinations = Array.from(presetMap.values()).reduce((sum, presets) => sum + presets.length * 3, 0);
            const confirmed = confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën ch·∫°y FaceSwap cho ${totalCombinations} combinations? (${presetMap.size} categories, ${allPresets.length} presets total)`);
            if (!confirmed) return;

            batchBtn.disabled = true;
            batchBtn.classList.add('loading');
            showLoading('ƒêang x·ª≠ l√Ω batch...');

            const results = [];
            let successCount = 0;
            let failCount = 0;
            let currentIndex = 0;

            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || '3:4';
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                const selectedFormat = localStorage.getItem('preset:format') || 'webp';
                const additionalPromptInput = document.getElementById('additional-prompt');
                const additionalPrompt = additionalPromptInput?.value.trim() || '';

                for (const [category, config] of Object.entries(presetCategories)) {
                    const categoryPresets = presetMap.get(category) || [];
                    if (categoryPresets.length === 0) continue;

                    for (const preset of categoryPresets) {
                        for (const tryImage of config.tryImages) {
                            currentIndex++;
                            const tryImageUrl = `/try/${config.tryPath}/${tryImage}`;
                            const usePresetUrl = !preset.id || preset.id?.startsWith('result-preset-');

                            try {
                                showLoading(`ƒêang x·ª≠ l√Ω: ${category} - ${preset.preset_id || preset.id} - ${tryImage} (${currentIndex}/${totalCombinations})`);

                                const requestBody = {
                                    ...(usePresetUrl
                                        ? { preset_image_url: preset.image_url }
                                        : { preset_image_id: preset.id || preset.preset_id }
                                    ),
                                    selfie_image_urls: [tryImageUrl],
                                    profile_id: window.profileManager.currentProfile.id,
                                    additional_prompt: additionalPrompt,
                                    aspect_ratio: selectedAspectRatio,
                                    model: selectedModel,
                                    format: selectedFormat,
                                    ...(selectedProvider && { provider: selectedProvider })
                                };

                                const faceswapUrl = `${WORKER_URL}/faceswap`;
                                const response = await fetch(faceswapUrl, {
                                    method: 'POST',
                                    headers: buildHeaders({ 'Content-Type': 'application/json' }),
                                    body: JSON.stringify(requestBody)
                                });

                                const data = await response.json();

                                if (response.ok && data.data?.resultImageUrl) {
                                    const resultUrl = data.data.resultImageUrl;
                                    const presetId = preset.preset_id || preset.id || 'unknown';
                                    const filename = `${category}_${presetId}_${tryImage.replace('.webp', '')}_result.webp`;
                                    
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    const downloaded = await downloadImage(resultUrl, filename);
                                    
                                    results.push({
                                        category: category,
                                        presetId: presetId,
                                        tryImage: tryImage,
                                        success: true,
                                        resultUrl: resultUrl,
                                        downloaded: downloaded
                                    });
                                    successCount++;
                                } else {
                                    throw new Error(data.message || 'FaceSwap failed');
                                }

                                await new Promise(resolve => setTimeout(resolve, 1000));
                            } catch (error) {
                                results.push({
                                    category: category,
                                    presetId: preset.preset_id || preset.id || 'unknown',
                                    tryImage: tryImage,
                                    success: false,
                                    error: error.message
                                });
                                failCount++;
                            }
                        }
                    }
                }

                const summary = `Ho√†n th√†nh! Th√†nh c√¥ng: ${successCount}, Th·∫•t b·∫°i: ${failCount}`;
                showStatusMessage(summary, successCount > 0 ? 'success' : 'error');

                await loadGallery('results');
            } catch (error) {
                showStatusMessage(`Batch processing failed: ${error.message}`, 'error');
            } finally {
                batchBtn.disabled = false;
                batchBtn.classList.remove('loading');
                hideLoading();
            }
        }

        let tryImagesResults = [];
        
        async function processTryImagesArray() {
            if (!window.profileManager?.currentProfile) {
                showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi x·ª≠ l√Ω.', 'error');
                return;
            }

            const input = document.getElementById('try-images-array-input');
            const processBtn = document.getElementById('process-try-images-btn');
            if (!input || !processBtn) return;

            const inputText = input.value.trim();
            if (!inputText) {
                showStatusMessage('Vui l√≤ng nh·∫≠p danh s√°ch ƒë∆∞·ªùng d·∫´n ·∫£nh.', 'error');
                return;
            }

            let imagePaths = [];
            try {
                // Try to convert JavaScript array notation (single quotes) to valid JSON (double quotes)
                let jsonText = inputText;
                if (inputText.startsWith('[') && inputText.includes("'")) {
                    jsonText = inputText.replace(/'/g, '"');
                }
                if (jsonText.startsWith('[') || jsonText.startsWith('"')) {
                    const parsed = JSON.parse(jsonText);
                    // Flatten nested arrays and ensure all items are strings
                    const flatten = (arr) => arr.reduce((acc, item) => {
                        if (Array.isArray(item)) {
                            return acc.concat(flatten(item));
                        }
                        return acc.concat(typeof item === 'string' ? item : String(item));
                    }, []);
                    imagePaths = Array.isArray(parsed) ? flatten(parsed) : [String(parsed)];
                } else {
                    imagePaths = inputText.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('//'));
                }
            } catch (e) {
                // If JSON parsing fails, try to extract URLs from the text
                const urlMatches = inputText.match(/https?:\/\/[^\s'"<>]+/g);
                if (urlMatches && urlMatches.length > 0) {
                    // Clean up any trailing punctuation from URLs
                    imagePaths = urlMatches.map(url => url.replace(/[,\]\)]+$/, ''));
                } else {
                    imagePaths = inputText.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('//'));
                }
            }
            // Filter out any empty or invalid paths
            imagePaths = imagePaths.filter(p => p && typeof p === 'string' && !p.startsWith('['));
            console.log('Parsed image paths:', imagePaths);

            if (imagePaths.length === 0) {
                showStatusMessage('Kh√¥ng t√¨m th·∫•y ƒë∆∞·ªùng d·∫´n ·∫£nh h·ª£p l·ªá.', 'error');
                return;
            }

            await loadGallery('preset');
            const allPresets = galleries.preset.state.items || [];
            if (allPresets.length === 0) {
                showStatusMessage('Kh√¥ng c√≥ preset n√†o trong gallery. Vui l√≤ng t·∫£i presets tr∆∞·ªõc.', 'error');
                return;
            }

            const categoryList = ['ai_avatar', 'ai_restore', 'ai_enhance', 'ai_beauty', 'ai_upscale_4k'];

            // Get selected category from dropdown (default to ai_avatar)
            const categoryFilterSelect = document.getElementById('try-results-filter');
            const selectedCategory = categoryFilterSelect?.value || 'ai_avatar';

            // Extract category from try image path (e.g., /try/ai_avatar/try_1.webp -> ai_avatar)
            // Falls back to dropdown selection if path doesn't contain category
            function extractCategoryFromPath(path) {
                for (const cat of categoryList) {
                    if (path.includes(`/${cat}/`) || path.includes(`/try/${cat}`)) {
                        return cat;
                    }
                }
                // Use dropdown selection if path doesn't match any category
                return selectedCategory !== 'all' ? selectedCategory : 'ai_avatar';
            }

            // Get exclude patterns from input
            function getExcludePatterns() {
                const excludeInput = document.getElementById('try-exclude-presets');
                const excludeValue = excludeInput?.value?.trim() || '';
                if (!excludeValue) return [];
                return excludeValue.split(',').map(p => p.trim()).filter(p => p.length > 0);
            }

            // Filter presets based on category prefix and exclude patterns
            function filterPresetsForCategory(presets, category) {
                const excludePatterns = getExcludePatterns();
                let filtered = presets;

                if (category === 'ai_avatar') {
                    // For AI Avatar, only use presets with 'fs_' prefix (face swap)
                    filtered = presets.filter(p => {
                        const presetId = p.preset_id || p.id || '';
                        return presetId.startsWith('fs_');
                    });
                    console.log(`Filtered presets for ai_avatar: ${filtered.length} of ${presets.length} (fs_ prefix)`);
                }

                // Apply exclude patterns
                if (excludePatterns.length > 0) {
                    const beforeExclude = filtered.length;
                    filtered = filtered.filter(p => {
                        const presetId = p.preset_id || p.id || '';
                        return !excludePatterns.some(pattern => presetId.includes(pattern));
                    });
                    console.log(`After excluding [${excludePatterns.join(', ')}]: ${filtered.length} of ${beforeExclude}`);
                }

                return filtered;
            }

            // LocalStorage functions for tracking completed uploads
            const TRY_UPLOADS_CACHE_KEY = 'try_uploads_completed';

            function getCompletedUploads() {
                try {
                    const cached = localStorage.getItem(TRY_UPLOADS_CACHE_KEY);
                    return cached ? JSON.parse(cached) : {};
                } catch (e) {
                    console.warn('Failed to parse completed uploads cache:', e);
                    return {};
                }
            }

            function saveCompletedUpload(targetR2Path) {
                try {
                    const completed = getCompletedUploads();
                    completed[targetR2Path] = Date.now();
                    localStorage.setItem(TRY_UPLOADS_CACHE_KEY, JSON.stringify(completed));
                } catch (e) {
                    console.warn('Failed to save completed upload:', e);
                }
            }

            function isUploadCompleted(targetR2Path) {
                const completed = getCompletedUploads();
                return !!completed[targetR2Path];
            }

            function clearTryUploadsCache() {
                try {
                    const completed = getCompletedUploads();
                    const count = Object.keys(completed).length;
                    localStorage.removeItem(TRY_UPLOADS_CACHE_KEY);
                    showStatusMessage(`Cleared ${count} cached upload records`, 'success');
                } catch (e) {
                    console.warn('Failed to clear cache:', e);
                }
            }

            // Calculate total tasks based on filtered presets per category
            let totalTasks = 0;
            const fsPresets = filterPresetsForCategory(allPresets, 'ai_avatar');
            const excludePatterns = getExcludePatterns();
            const completedUploads = getCompletedUploads();
            const completedCount = Object.keys(completedUploads).length;

            for (const imagePath of imagePaths) {
                const category = extractCategoryFromPath(imagePath);
                const filteredCount = category === 'ai_avatar' ? fsPresets.length : allPresets.length;
                totalTasks += filteredCount;
            }

            let confirmMsg = `B·∫°n c√≥ ch·∫Øc mu·ªën x·ª≠ l√Ω ${imagePaths.length} ·∫£nh try v·ªõi ~${totalTasks} tasks?\n`;
            confirmMsg += `(AI Avatar: ${fsPresets.length} presets c√≥ prefix 'fs_')`;
            if (excludePatterns.length > 0) {
                confirmMsg += `\nExcluding: ${excludePatterns.join(', ')}`;
            }
            if (completedCount > 0) {
                confirmMsg += `\n${completedCount} completed uploads will be skipped (cached)`;
            }
            const confirmed = confirm(confirmMsg);
            if (!confirmed) return;

            processBtn.disabled = true;
            processBtn.classList.add('loading');
            showLoading('ƒêang x·ª≠ l√Ω try images...');
            tryImagesResults = [];

            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || '3:4';
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                const selectedFormat = localStorage.getItem('preset:format') || 'webp';
                const additionalPromptInput = document.getElementById('additional-prompt');
                const additionalPrompt = additionalPromptInput?.value.trim() || '';

                // Build all tasks first, skipping already-completed uploads
                const allTasks = [];
                let skippedCount = 0;
                for (const imagePath of imagePaths) {
                    const normalizedPath = imagePath.trim();
                    if (!normalizedPath) continue;

                    const category = extractCategoryFromPath(normalizedPath);
                    const filteredPresets = filterPresetsForCategory(allPresets, category);
                    if (filteredPresets.length === 0) {
                        console.warn(`No presets found for category: ${category} (looking for fs_ prefix)`);
                        continue;
                    }

                    const tryImageMatch = normalizedPath.match(/try_(\d+)/);
                    const tryImageName = tryImageMatch ? `try_${tryImageMatch[1]}` : 'try_unknown';

                    for (const preset of filteredPresets) {
                        if (!preset || (!preset.id && !preset.preset_id && !preset.image_url)) continue;
                        const presetId = preset.preset_id || preset.id || 'unknown';
                        const targetR2Path = `try_results/${category}/${presetId}_${tryImageName}.webp`;

                        // Skip if already completed
                        if (isUploadCompleted(targetR2Path)) {
                            skippedCount++;
                            console.log(`Skipping already completed: ${targetR2Path}`);
                            continue;
                        }

                        const usePresetUrl = !preset.id || preset.id?.startsWith('result-preset-');
                        const tryImageUrl = normalizedPath.startsWith('http') ? normalizedPath : (normalizedPath.startsWith('/') ? normalizedPath : `/${normalizedPath}`);
                        const fullTryImageUrl = tryImageUrl.startsWith('http') ? tryImageUrl : `${WORKER_URL}${tryImageUrl}`;

                        allTasks.push({
                            category, presetId, usePresetUrl, preset, normalizedPath, tryImageName, fullTryImageUrl, targetR2Path
                        });
                    }
                }

                if (skippedCount > 0) {
                    showStatusMessage(`Skipped ${skippedCount} already-completed uploads`, 'info');
                }

                // Process task function with retry for 429
                async function processTask(task, index) {
                    const { category, presetId, usePresetUrl, preset, normalizedPath, tryImageName, fullTryImageUrl, targetR2Path } = task;
                    const MAX_RETRIES = 5;
                    let retryCount = 0;

                    while (retryCount <= MAX_RETRIES) {
                        try {
                            const requestBody = {
                                ...(usePresetUrl
                                    ? { preset_image_url: preset.image_url }
                                    : { preset_image_id: presetId }
                                ),
                                selfie_image_urls: [fullTryImageUrl],
                                profile_id: window.profileManager.currentProfile.id,
                                additional_prompt: additionalPrompt,
                                aspect_ratio: selectedAspectRatio,
                                model: selectedModel,
                                format: selectedFormat,
                                ...(selectedProvider && { provider: selectedProvider })
                            };

                            const response = await fetch(`${WORKER_URL}/faceswap`, {
                                method: 'POST',
                                headers: buildHeaders({ 'Content-Type': 'application/json' }),
                                body: JSON.stringify(requestBody)
                            });

                            // Handle 429 with exponential backoff
                            if (response.status === 429) {
                                retryCount++;
                                if (retryCount <= MAX_RETRIES) {
                                    const delay = Math.min(1000 * Math.pow(2, retryCount) + Math.random() * 1000, 30000);
                                    console.warn(`429 Rate limited for ${presetId}, retry ${retryCount}/${MAX_RETRIES} in ${Math.round(delay/1000)}s`);
                                    await new Promise(r => setTimeout(r, delay));
                                    continue;
                                }
                                throw new Error('Rate limited (429) - max retries exceeded');
                            }

                            const data = await response.json();

                            if (response.ok && data.data?.resultImageUrl) {
                                const resultUrl = data.data.resultImageUrl;

                                // Upload result image to R2
                                let r2Uploaded = false;
                                let r2Url = null;
                                try {
                                    const imageResponse = await fetch(resultUrl);
                                    if (imageResponse.ok) {
                                        const imageBlob = await imageResponse.blob();
                                        const contentType = imageBlob.type || 'image/webp';
                                        const uploadResponse = await fetch(`${WORKER_URL}/r2-upload/${encodeURIComponent(targetR2Path)}?contentType=${encodeURIComponent(contentType)}`, {
                                            method: 'PUT',
                                            headers: buildHeaders({}),
                                            body: imageBlob
                                        });

                                        if (uploadResponse.ok) {
                                            r2Uploaded = true;
                                            r2Url = `https://resources.d.shotpix.app/${targetR2Path}`;
                                            saveCompletedUpload(targetR2Path); // Save to localStorage
                                            console.log(`Uploaded to R2: ${targetR2Path}`);
                                        } else {
                                            console.warn(`R2 upload failed for ${targetR2Path}:`, await uploadResponse.text());
                                        }
                                    }
                                } catch (uploadError) {
                                    console.warn(`Failed to upload to R2: ${targetR2Path}`, uploadError);
                                }

                                return {
                                    category, presetId, tryImage: normalizedPath, tryImageName,
                                    resultUrl, targetR2Path, r2Uploaded, r2Url,
                                    presetName: presetId, timestamp: new Date().toISOString(), retries: retryCount
                                };
                            } else {
                                throw new Error(data.message || 'FaceSwap failed');
                            }
                        } catch (error) {
                            if (retryCount >= MAX_RETRIES || !error.message?.includes('429')) {
                                console.error(`Error processing ${category}/${presetId}/${normalizedPath}:`, error);
                                return {
                                    category, presetId, tryImage: normalizedPath, tryImageName,
                                    resultUrl: null, targetR2Path,
                                    error: error.message, presetName: presetId, timestamp: new Date().toISOString(), retries: retryCount
                                };
                            }
                            retryCount++;
                        }
                    }
                }

                // Process in parallel batches of 5 (reduced from 10 to avoid rate limits)
                const BATCH_SIZE = 5;
                const BATCH_DELAY = 2000; // 2 second delay between batches
                let completedCount = 0;
                let rateLimitCount = 0;

                for (let i = 0; i < allTasks.length; i += BATCH_SIZE) {
                    const batch = allTasks.slice(i, i + BATCH_SIZE);
                    const batchNum = Math.floor(i / BATCH_SIZE) + 1;
                    const totalBatches = Math.ceil(allTasks.length / BATCH_SIZE);
                    showLoading(`Batch ${batchNum}/${totalBatches} (${completedCount}/${allTasks.length} done, ${rateLimitCount} retried)`);

                    const batchResults = await Promise.all(batch.map((task, idx) => processTask(task, i + idx)));
                    tryImagesResults.push(...batchResults);
                    completedCount += batch.length;
                    rateLimitCount += batchResults.filter(r => r.retries > 0).length;
                    renderTryResults();

                    // Delay between batches to avoid rate limits
                    if (i + BATCH_SIZE < allTasks.length) {
                        await new Promise(r => setTimeout(r, BATCH_DELAY));
                    }
                }

                const successCount = tryImagesResults.filter(r => r.resultUrl).length;
                const failCount = tryImagesResults.filter(r => !r.resultUrl).length;
                const r2UploadedCount = tryImagesResults.filter(r => r.r2Uploaded).length;
                const summary = `Ho√†n th√†nh! Th√†nh c√¥ng: ${successCount}, R2: ${r2UploadedCount}, Th·∫•t b·∫°i: ${failCount}`;
                showStatusMessage(summary, successCount > 0 ? 'success' : 'error');

                await loadGallery('results');
            } catch (error) {
                showStatusMessage(`X·ª≠ l√Ω th·∫•t b·∫°i: ${error.message}`, 'error');
                console.error('Try images processing error:', error);
            } finally {
                processBtn.disabled = false;
                processBtn.classList.remove('loading');
                hideLoading();
            }
        }

        function renderTryResults() {
            const gallery = document.getElementById('try-results-gallery');
            const filterSelect = document.getElementById('try-results-filter');
            const countSpan = document.getElementById('try-results-count');
            if (!gallery || !filterSelect || !countSpan) return;

            const selectedCategory = filterSelect.value;
            const filteredResults = selectedCategory === 'all' 
                ? tryImagesResults 
                : tryImagesResults.filter(r => r.category === selectedCategory);

            countSpan.textContent = `${filteredResults.length} results`;

            gallery.innerHTML = filteredResults.map((result, index) => {
                if (!result.resultUrl) {
                    return `<div style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--danger);" title="${result.targetR2Path || ''}">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">${result.presetId}_${result.tryImageName || 'try'}</div>
                        <div style="font-size: 10px; color: var(--danger); word-break: break-all;">Error: ${result.error || 'Failed'}</div>
                        <div style="font-size: 9px; color: var(--text-muted); margin-top: 4px;">${result.category}</div>
                    </div>`;
                }

                return `<div style="position: relative; background: var(--bg-primary); border-radius: 8px; overflow: hidden; border: 1px solid var(--border); cursor: pointer;" onclick="displayResultInPreview('${result.resultUrl}')" title="${result.targetR2Path || ''}">
                    <img src="${result.resultUrl}" style="width: 100%; height: 120px; object-fit: cover; display: block;" loading="lazy" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'padding: 20px; text-align: center; color: var(--text-muted);\\'>Failed to load</div>'">
                    <div style="padding: 6px; background: rgba(0,0,0,0.6); position: absolute; bottom: 0; left: 0; right: 0; color: #fff; font-size: 9px;">
                        <div style="font-weight: 600; margin-bottom: 2px;">${result.presetId}_${result.tryImageName || 'try'}</div>
                        <div style="opacity: 0.8; font-size: 8px; word-break: break-all;">${result.category}</div>
                    </div>
                </div>`;
            }).join('');

            if (filteredResults.length === 0) {
                gallery.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-muted);">No results yet. Process some images first.</div>';
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                const filterSelect = document.getElementById('try-results-filter');
                if (filterSelect) {
                    filterSelect.addEventListener('change', renderTryResults);
                }
                renderTryResults();
            });
        } else {
            const filterSelect = document.getElementById('try-results-filter');
            if (filterSelect) {
                filterSelect.addEventListener('change', renderTryResults);
            }
            renderTryResults();
        }

        // Make Try Images functions globally accessible for onclick handlers
        window.processTryImagesArray = processTryImagesArray;
        window.renderTryResults = renderTryResults;

        async function generateBackground() {
            const presetSelected = galleries.preset.state.selected;
            const selfieSelected = galleries.selfie.state.selected;
            const selfieArray = Array.isArray(selfieSelected) ? selfieSelected : (selfieSelected ? [selfieSelected] : []);
            const additionalPromptInput = document.getElementById('additional-prompt');
            const customPrompt = additionalPromptInput?.value.trim() || '';
            
            if (!presetSelected && !customPrompt) { 
                showStatusMessage('Vui l√≤ng ch·ªçn m·∫´u (preset) ho·∫∑c nh·∫≠p prompt t√πy ch·ªânh ƒë·ªÉ t·∫°o n·ªÅn AI.', 'error'); 
                return; 
            }
            if (presetSelected && customPrompt) {
                // When both preset and custom prompt are provided, use custom prompt as additional_prompt for merge
                // This allows users to use custom prompt as additional instructions when preset is selected
            }
            if (selfieArray.length === 0) { showStatusMessage('Vui l√≤ng ch·ªçn selfie tr∆∞·ªõc khi t·∫°o n·ªÅn AI.', 'error'); return; }
            if (!window.profileManager?.currentProfile) { showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi t·∫°o n·ªÅn AI.', 'error'); return; }

            const selectedSelfie = selfieArray[0];

            showLoading('ƒêang t·∫°o n·ªÅn AI...');

            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || '3:4';
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                const providerSelect = document.getElementById('image-provider');
                const selectedProvider = providerSelect?.value || localStorage.getItem('faceswap:provider') || '';
                const useSelfieUrl = !selectedSelfie.id || selectedSelfie.id?.startsWith('result-selfie-');
                
                const requestBody = {
                    ...(customPrompt && !presetSelected
                        ? { custom_prompt: customPrompt }
                        : (() => {
                            if (!presetSelected) return {};
                            const presetId = presetSelected.preset_id || presetSelected.id;
                            const usePresetUrl = !presetId || presetId.startsWith('result-preset-');
                            return usePresetUrl 
                                ? { preset_image_url: presetSelected.image_url }
                                : { preset_image_id: presetId };
                        })()
                    ),
                    ...(useSelfieUrl 
                        ? { selfie_image_url: selectedSelfie.image_url }
                        : { selfie_id: selectedSelfie.id }
                    ),
                    profile_id: window.profileManager.currentProfile.id,
                    ...(presetSelected && customPrompt ? { additional_prompt: customPrompt } : {}),
                    aspect_ratio: selectedAspectRatio,
                    model: selectedModel,
                    ...(selectedProvider && { provider: selectedProvider })
                };

                const backgroundUrl = `${WORKER_URL}/background`;
                const startTime = Date.now();
                const response = await fetch(backgroundUrl, { method: 'POST', headers: buildHeaders({ 'Content-Type': 'application/json' }), body: JSON.stringify(requestBody) });
                const data = await response.json();
                const duration = Date.now() - startTime;

                logApiCall({ label: 'N·ªÅn AI', method: 'POST', url: '/background', fullUrl: backgroundUrl, status: response.ok ? 'success' : 'error', payload: data, duration, headers: { 'Content-Type': 'application/json' }, body: requestBody });
                if (!response.ok || !data.data?.resultImageUrl) throw new Error(data.message || 'T·∫°o n·ªÅn AI th·∫•t b·∫°i');

                await loadGallery('results');
                
                const loadedResults = galleries.results.state.items;
                const newResult = loadedResults.find(r => r.result_url === data.data.resultImageUrl) || 
                                 { id: data.data.id || `result-${Date.now()}`, result_url: data.data.resultImageUrl, image_url: data.data.resultImageUrl, created_at: new Date().toISOString() };
                
                displayResultInPreview(newResult.image_url);
                updateResultsCount();
                showStatusMessage('T·∫°o n·ªÅn AI th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatusMessage(`T·∫°o n·ªÅn AI th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function runImageOperation(label, endpoint, extra = {}) {
            const selfieSelected = galleries.selfie.state.selected;
            const selfieArray = Array.isArray(selfieSelected) ? selfieSelected : (selfieSelected ? [selfieSelected] : []);
            if (selfieArray.length === 0) { showStatusMessage('Ch·ªçn selfie ƒë·ªÉ ch·∫°y API.', 'error'); return; }
            if (!window.profileManager?.currentProfile) { showStatusMessage('H·ªì s∆° ch∆∞a s·∫µn s√†ng.', 'error'); return; }

            // Use the first selfie for image operations
            const selectedSelfie = selfieArray[0];

            showLoading(label);
            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || 'original';
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                console.log(`[${label}] Aspect ratio select value:`, aspectRatioSelect?.value);
                console.log(`[${label}] Selected aspect ratio:`, selectedAspectRatio);
                console.log(`[${label}] Selected model:`, selectedModel);

                const providerSelect = document.getElementById('image-provider');
                const selectedProvider = providerSelect?.value || localStorage.getItem('faceswap:provider') || '';
                const payload = {
                    image_url: selectedSelfie.image_url,
                    profile_id: window.profileManager.currentProfile.id,
                    aspect_ratio: selectedAspectRatio === 'original' ? 'original' : selectedAspectRatio,
                    model: selectedModel,
                    ...(selectedProvider && { provider: selectedProvider }),
                    ...extra
                };
                console.log(`[${label}] Full request body:`, JSON.stringify(payload, null, 2));
                console.log(`[${label}] Sending request with aspect_ratio:`, payload.aspect_ratio);
                
                const startTime = Date.now();
                const operationUrl = `${WORKER_URL}/${endpoint}`;
                const response = await fetch(operationUrl, { method: 'POST', headers: buildHeaders({ 'Content-Type': 'application/json' }), body: JSON.stringify(payload) });
                const data = await response.json();
                const duration = Date.now() - startTime;

                logApiCall({ label, method: 'POST', url: `/${endpoint}`, fullUrl: operationUrl, status: response.ok ? 'success' : 'error', payload: data, duration, headers: { 'Content-Type': 'application/json' }, body: payload });
                if (!response.ok || !data?.data?.resultImageUrl) throw new Error(data.message || `${label} th·∫•t b·∫°i`);

                displayResultInPreview(data.data.resultImageUrl);
                showStatusMessage(`${label} th√†nh c√¥ng`, 'success');
                await loadGallery('results');
                updateResultsCount();
            } catch (error) {
                showStatusMessage(`${label} th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        function runEnhance() { runImageOperation('N√¢ng C·∫•p (Enhance)', 'enhance'); }
        function runBeauty() { runImageOperation('L√†m ƒê·∫πp (Beauty)', 'beauty'); }
        function runUpscale4k() {
            const selfieSelected = galleries.selfie.state.selected;
            const selfieArray = Array.isArray(selfieSelected) ? selfieSelected : (selfieSelected ? [selfieSelected] : []);
            if (selfieArray.length === 0) {
                showStatusMessage('Ch·ªçn selfie ƒë·ªÉ ch·∫°y API.', 'error');
                return;
            }
            const selectedSelfie = selfieArray[0];
            // Validate that the selected selfie has action="4k" or "4K"
            const selfieAction = selectedSelfie.action?.toLowerCase();
            if (!selfieAction || selfieAction !== '4k') {
                showStatusMessage('Ch·ªâ c√≥ th·ªÉ s·ª≠ d·ª•ng selfie v·ªõi action="4k" cho 4K Upscale. Vui l√≤ng upload selfie m·ªõi v·ªõi action="4k" (ch·ªçn "4K Upscale (Max 1)" trong dropdown Action khi upload) ho·∫∑c ch·ªçn selfie kh√°c c√≥ action="4k".', 'error');
                return;
            }
            runImageOperation('N√¢ng C·∫•p 4K (4K Upscale)', 'upscaler4k');
        }
        function runRestore() { runImageOperation('Kh√¥i Ph·ª•c (Restore)', 'restore'); }
        function runAging() { runImageOperation('L√£o H√≥a (Aging)', 'aging', { age_years: parseInt($('aging-years')?.value || '20', 10) }); }
        
        async function runFilter() {
            const presetSelected = galleries.preset.state.selected;
            const selfieSelected = galleries.selfie.state.selected;
            const selfieArray = Array.isArray(selfieSelected) ? selfieSelected : (selfieSelected ? [selfieSelected] : []);
            
            if (!presetSelected) { showStatusMessage('Vui l√≤ng ch·ªçn m·∫´u (preset) tr∆∞·ªõc khi √°p d·ª•ng b·ªô l·ªçc.', 'error'); return; }
            if (selfieArray.length === 0) { showStatusMessage('Vui l√≤ng ch·ªçn selfie tr∆∞·ªõc khi √°p d·ª•ng b·ªô l·ªçc.', 'error'); return; }
            if (!window.profileManager?.currentProfile) { showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi √°p d·ª•ng b·ªô l·ªçc.', 'error'); return; }

            const selectedSelfie = selfieArray[0];

            showLoading('ƒêang √°p d·ª•ng b·ªô l·ªçc...');

            try {
                const aspectRatioSelect = document.getElementById('aspect-ratio');
                const selectedAspectRatio = aspectRatioSelect?.value || localStorage.getItem('faceswap:aspectRatio') || '3:4';
                const modelSelect = document.getElementById('gemini-model');
                const selectedModel = modelSelect?.value || localStorage.getItem('faceswap:model') || '2.5';
                const providerSelect = document.getElementById('image-provider');
                const selectedProvider = providerSelect?.value || localStorage.getItem('faceswap:provider') || '';
                const presetId = presetSelected.preset_id || presetSelected.id;
                const usePresetUrl = !presetId || presetId.startsWith('result-preset-');
                const useSelfieUrl = !selectedSelfie.id || selectedSelfie.id?.startsWith('result-selfie-');
                const additionalPromptInput = document.getElementById('additional-prompt');
                const requestBody = {
                    ...(usePresetUrl 
                        ? { preset_image_url: presetSelected.image_url }
                        : { preset_image_id: presetId }
                    ),
                    ...(useSelfieUrl 
                        ? { selfie_image_url: selectedSelfie.image_url }
                        : { selfie_id: selectedSelfie.id }
                    ),
                    profile_id: window.profileManager.currentProfile.id,
                    additional_prompt: additionalPromptInput?.value.trim() || '',
                    aspect_ratio: selectedAspectRatio,
                    model: selectedModel,
                    ...(selectedProvider && { provider: selectedProvider })
                };

                const filterUrl = `${WORKER_URL}/filter`;
                const startTime = Date.now();
                const response = await fetch(filterUrl, { method: 'POST', headers: buildHeaders({ 'Content-Type': 'application/json' }), body: JSON.stringify(requestBody) });
                const data = await response.json();
                const duration = Date.now() - startTime;

                logApiCall({ label: 'B·ªô L·ªçc (Filter)', method: 'POST', url: '/filter', fullUrl: filterUrl, status: response.ok ? 'success' : 'error', payload: data, duration, headers: { 'Content-Type': 'application/json' }, body: requestBody });
                if (!response.ok || !data.data?.resultImageUrl) throw new Error(data.message || '√Åp d·ª•ng b·ªô l·ªçc th·∫•t b·∫°i');

                await loadGallery('results');
                
                const loadedResults = galleries.results.state.items;
                const newResult = loadedResults.find(r => r.result_url === data.data.resultImageUrl) || 
                                 { id: data.data.id || `result-${Date.now()}`, result_url: data.data.resultImageUrl, image_url: data.data.resultImageUrl, created_at: new Date().toISOString() };
                
                displayResultInPreview(newResult.image_url);
                updateResultsCount();
                showStatusMessage('√Åp d·ª•ng b·ªô l·ªçc th√†nh c√¥ng!', 'success');
            } catch (error) {
                showStatusMessage(`√Åp d·ª•ng b·ªô l·ªçc th·∫•t b·∫°i: ${error.message}`, 'error');
            } finally {
                hideLoading();
                updateImageOperationButtons();
            }
        }

        function displayResultInPreview(imageUrl) {
            const resultPreview = $('result-preview');
            if (resultPreview && imageUrl) {
                resultPreview.innerHTML = `<img src="${imageUrl}" alt="Result" style="cursor: pointer;" onclick="openPreviewLightbox('result')">`;
            }
        }
        window.displayResultInPreview = displayResultInPreview;

        // Lightbox
        let lightboxCurrentIndex = -1, lightboxItems = [];
        let lightboxKeyboardHandler = null;
        let lightboxMode = 'gallery'; // 'gallery' for results gallery, 'preview' for preset/selfie/result preview
        let comparisonItems = [];
        const COMPARISON_STORAGE_KEY = 'faceswap_comparison_items';
        
        // Load comparison from localStorage
        function loadComparisonFromStorage() {
            try {
                const stored = localStorage.getItem(COMPARISON_STORAGE_KEY);
                if (stored) {
                    comparisonItems = JSON.parse(stored);
                } else {
                    comparisonItems = [];
                }
            } catch (e) {
                comparisonItems = [];
            }
        }
        
        // Save comparison to localStorage
        function saveComparisonToStorage() {
            try {
                localStorage.setItem(COMPARISON_STORAGE_KEY, JSON.stringify(comparisonItems));
                updateComparisonButton();
            } catch (e) {
                console.error('Failed to save comparison to storage:', e);
            }
        }
        
        // Update comparison button count
        function updateComparisonButton() {
            const btn = $('comparison-count');
            if (btn) {
                btn.textContent = comparisonItems.length;
            }
        }
        
        // Initialize comparison on page load
        loadComparisonFromStorage();
        updateComparisonButton();

        function openLightbox(index) {
            // Scroll to top to ensure lightbox is visible
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            lightboxMode = 'gallery';
            lightboxItems = galleries.results.state.items;
            if (index >= 0 && index < lightboxItems.length) {
                lightboxCurrentIndex = index;
                updateLightbox();
                setupLightboxKeyboard();
            }
        }

        function openPresetLightbox(presetId) {
            // Scroll to top to ensure lightbox is visible
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            const allPresets = galleries.preset.state.items;
            if (!allPresets || allPresets.length === 0) return;

            // Find all items with the same preset_id (WebP, Lottie, etc.)
            const presetItems = allPresets.filter(item => (item.preset_id || item.id) === presetId);
            if (presetItems.length === 0) return;

            lightboxMode = 'preset-preview';
            
            // Map all formats of this preset to lightboxItems
            lightboxItems = presetItems.map(preset => ({
                type: 'preset',
                id: preset.id,
                preset_id: preset.preset_id || presetId,
                image_url: preset.thumbnail_url_4x || preset.image_url,
                thumbnail_url_4x: preset.thumbnail_url_4x,
                format: preset.format,
                label: `Preset: ${preset.preset_id || presetId}${preset.format ? ' (' + preset.format + ')' : ''}`
            }));

            // Start at first item (prefer WebP if available)
            const webpIndex = lightboxItems.findIndex(item => item.format === 'webp' || (!item.format && !item.thumbnail_url_4x?.toLowerCase().endsWith('.json')));
            lightboxCurrentIndex = webpIndex >= 0 ? webpIndex : 0;

            updateLightbox();
            setupLightboxKeyboard();

            // Ensure actions are visible for preset preview
            const actions = $('lightbox-actions');
            if (actions) {
                actions.style.display = 'flex';
                actions.style.visibility = 'visible';
            }
        }

        function openSelfieLightbox(selfieId) {
            // Scroll to top to ensure lightbox is visible
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            const allSelfies = galleries.selfie.state.items;
            if (!allSelfies || allSelfies.length === 0) return;

            const clickedSelfie = allSelfies.find(item => item.id === selfieId);
            if (!clickedSelfie) return;

            lightboxMode = 'selfie-preview';
            
            lightboxItems = allSelfies.map(selfie => ({
                type: 'selfie',
                id: selfie.id,
                image_url: selfie.image_url || selfie.selfie_url,
                label: `Selfie: ${selfie.id}`
            }));

            lightboxCurrentIndex = lightboxItems.findIndex(item => item.id === selfieId);
            if (lightboxCurrentIndex < 0) lightboxCurrentIndex = 0;

            updateLightbox();
            setupLightboxKeyboard();

            const actions = $('lightbox-actions');
            if (actions) {
                actions.style.display = 'flex';
            }
        }

        function openPreviewLightbox(startType, selfieIndex) {
            // Scroll to top to ensure lightbox is visible
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            lightboxMode = 'preview';
            lightboxItems = [];
            
            const presetSelected = galleries.preset.state.selected;
            const selfieSelected = galleries.selfie.state.selected;
            const resultPreview = $('result-preview');
            const resultImg = resultPreview?.querySelector('img');
            const resultUrl = resultImg?.src;
            
            if (presetSelected) {
                lightboxItems.push({
                    type: 'preset',
                    image_url: presetSelected.thumbnail_url_4x || presetSelected.image_url,
                    thumbnail_url_4x: presetSelected.thumbnail_url_4x,
                    label: 'M·∫´u (Preset)'
                });
            }
            if (selfieSelected) {
                if (Array.isArray(selfieSelected)) {
                    // Add all selected selfies
                    selfieSelected.forEach((selfie, index) => {
                        lightboxItems.push({
                            type: 'selfie',
                            image_url: selfie.image_url,
                            label: `·∫¢nh T·ª± S∆∞·ªõng ${index + 1} (Selfie ${index + 1})`
                        });
                    });
                } else {
                    lightboxItems.push({
                        type: 'selfie',
                        image_url: selfieSelected.image_url,
                        label: '·∫¢nh T·ª± S∆∞·ªõng (Selfie)'
                    });
                }
            }
            if (resultUrl && resultUrl !== '' && !resultUrl.includes('data:image/svg') && resultUrl !== window.location.href) {
                lightboxItems.push({
                    type: 'result',
                    image_url: resultUrl,
                    label: 'K·∫øt Qu·∫£ (Result)'
                });
            }
            
            if (lightboxItems.length === 0) return;
            
            // If selfieIndex is provided and we have multiple selfies, start at that selfie
            if (startType === 'selfie' && typeof selfieIndex === 'number' && Array.isArray(selfieSelected)) {
                const presetOffset = presetSelected ? 1 : 0;
                lightboxCurrentIndex = presetOffset + selfieIndex;
            } else {
                const startIndex = lightboxItems.findIndex(item => item.type === startType);
                lightboxCurrentIndex = startIndex >= 0 ? startIndex : 0;
            }
            updateLightbox();
            setupLightboxKeyboard();
        }

        function closeLightbox() {
            $('lightbox').style.display = 'none';
            lightboxCurrentIndex = -1;
            lightboxItems = [];
            lightboxMode = 'gallery';
            removeLightboxKeyboard();
            // Reset to single view when closing
            const comparisonContainer = $('lightbox-comparison');
            const singleView = $('lightbox-single');
            if (comparisonContainer && singleView) {
                comparisonContainer.style.display = 'none';
                singleView.style.display = 'flex';
            }
        }

        function lightboxNavigate(delta) {
            if (lightboxItems.length) {
                lightboxCurrentIndex = (lightboxCurrentIndex + delta + lightboxItems.length) % lightboxItems.length;
                updateLightbox();
            }
        }

        function setupLightboxKeyboard() {
            if (lightboxKeyboardHandler) return;
            lightboxKeyboardHandler = (e) => {
                if (e.key === 'Escape') {
                    closeLightbox();
                } else if (e.key === 'ArrowLeft') {
                    lightboxNavigate(-1);
                } else if (e.key === 'ArrowRight') {
                    lightboxNavigate(1);
                }
            };
            document.addEventListener('keydown', lightboxKeyboardHandler);
        }

        function removeLightboxKeyboard() {
            if (lightboxKeyboardHandler) {
                document.removeEventListener('keydown', lightboxKeyboardHandler);
                lightboxKeyboardHandler = null;
            }
        }

        function updateLightbox() {
            const lightbox = $('lightbox'), img = $('lightbox-image'), counter = $('lightbox-counter');
            const actions = $('lightbox-actions');
            const addToComparisonBtn = $('add-to-comparison-btn');
            if (!lightbox || lightboxCurrentIndex < 0 || lightboxCurrentIndex >= lightboxItems.length) return;
            const item = lightboxItems[lightboxCurrentIndex];
            const imageUrl = item.result_url || item.image_url || '';

            if (lightboxMode === 'gallery') {
                const single = $('lightbox-single');
                if (!single) return;

                let info = single.querySelector('.lightbox-info');
                if (!info) {
                    info = document.createElement('div');
                    info.className = 'lightbox-info';
                    single.appendChild(info);
                }

                Array.from(single.children).forEach(child => {
                    if (!child.classList.contains('lightbox-info') && !child.classList.contains('lightbox-actions')) {
                        child.remove();
                    }
                });

                if (imageUrl) {
                    let displayImg = img;
                    if (!displayImg || !single.contains(displayImg)) {
                        displayImg = document.createElement('img');
                        displayImg.id = 'lightbox-image';
                    }
                    displayImg.src = imageUrl;
                    displayImg.alt = 'Result';
                    displayImg.style.cssText = 'max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; display: block;';
                    if (!single.contains(displayImg)) {
                        single.insertBefore(displayImg, info);
                    }
                }

                // Show counter and actual result URL for gallery mode (no prompt JSON)
                if (counter) counter.textContent = `K·∫øt Qu·∫£ (Result) (${lightboxCurrentIndex + 1} / ${lightboxItems.length})`;
                if (info) {
                    info.innerHTML = `
                        <span id="lightbox-counter">${counter ? counter.textContent : ''}</span>
                        <div style="color: #999; font-size: 11px; word-break: break-all; font-family: monospace; margin-top: 8px; max-width: 600px;">${imageUrl}</div>
                    `;
                }

                const actions = $('lightbox-actions');
                if (actions) {
                    actions.style.display = 'flex';
                }
            } else if (lightboxMode === 'selfie-preview') {
                const single = $('lightbox-single');
                if (!single) return;

                let info = single.querySelector('.lightbox-info');
                if (!info) {
                    info = document.createElement('div');
                    info.className = 'lightbox-info';
                    single.appendChild(info);
                }

                // Find or ensure actions element exists
                let actionsDiv = single.querySelector('.lightbox-actions');
                if (!actionsDiv) {
                    actionsDiv = $('lightbox-actions');
                    if (actionsDiv && actionsDiv.parentNode !== single) {
                        single.appendChild(actionsDiv);
                    } else if (!actionsDiv) {
                        // Create actions div if it doesn't exist
                        actionsDiv = document.createElement('div');
                        actionsDiv.className = 'lightbox-actions';
                        actionsDiv.id = 'lightbox-actions';
                        actionsDiv.innerHTML = `
                            <button class="lightbox-action-btn" onclick="selectAsPreset()">
                                <span>üì∏</span>
                                <span>Ch·ªçn l√†m M·∫´u</span>
                            </button>
                            <button class="lightbox-action-btn secondary" onclick="selectAsSelfie()">
                                <span>üë§</span>
                                <span>Ch·ªçn l√†m Selfie</span>
                            </button>
                            <button class="lightbox-action-btn" onclick="addToComparison()" id="add-to-comparison-btn">
                                <span>‚ûï</span>
                                <span>Th√™m v√†o So S√°nh</span>
                            </button>
                        `;
                        single.appendChild(actionsDiv);
                    }
                }

                Array.from(single.children).forEach(child => {
                    if (!child.classList.contains('lightbox-info') && !child.classList.contains('lightbox-actions')) {
                        child.remove();
                    }
                });

                if (imageUrl) {
                    let displayImg = img;
                    if (!displayImg || !single.contains(displayImg)) {
                        displayImg = document.createElement('img');
                        displayImg.id = 'lightbox-image';
                    }
                    displayImg.src = imageUrl;
                    displayImg.alt = 'Selfie';
                    displayImg.style.cssText = 'max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; display: block;';
                    if (!single.contains(displayImg)) {
                        single.insertBefore(displayImg, info);
                    }
                }

                if (counter) counter.textContent = `${item.label} (${lightboxCurrentIndex + 1} / ${lightboxItems.length})`;

                const actions = $('lightbox-actions');
                if (actions) {
                    actions.style.display = 'flex';
                }
            } else if (lightboxMode === 'preview' || lightboxMode === 'preset-preview') {
                // Handle WebP media for presets
                const single = $('lightbox-single');
                if (!single) return;

                // Find or create info element
                let info = single.querySelector('.lightbox-info');
                if (!info) {
                    info = document.createElement('div');
                    info.className = 'lightbox-info';
                    single.appendChild(info);
                }

                // Find or ensure actions element exists
                let actionsDiv = single.querySelector('.lightbox-actions');
                if (!actionsDiv) {
                    actionsDiv = $('lightbox-actions');
                    if (actionsDiv && actionsDiv.parentNode !== single) {
                        single.appendChild(actionsDiv);
                    } else if (!actionsDiv) {
                        // Create actions div if it doesn't exist
                        actionsDiv = document.createElement('div');
                        actionsDiv.className = 'lightbox-actions';
                        actionsDiv.id = 'lightbox-actions';
                        actionsDiv.innerHTML = `
                            <button class="lightbox-action-btn" onclick="selectAsPreset()">
                                <span>üì∏</span>
                                <span>Ch·ªçn l√†m M·∫´u</span>
                            </button>
                            <button class="lightbox-action-btn secondary" onclick="selectAsSelfie()">
                                <span>üë§</span>
                                <span>Ch·ªçn l√†m Selfie</span>
                            </button>
                            <button class="lightbox-action-btn" onclick="addToComparison()" id="add-to-comparison-btn">
                                <span>‚ûï</span>
                                <span>Th√™m v√†o So S√°nh</span>
                            </button>
                        `;
                        single.appendChild(actionsDiv);
                    }
                }

                // Clear only media elements (img or container divs), keep info and actions
                // Also destroy any existing Lottie animations
                Array.from(single.children).forEach(child => {
                    if (!child.classList.contains('lightbox-info') && !child.classList.contains('lightbox-actions')) {
                        if (child.lottieInstance) {
                            try {
                                child.lottieInstance.destroy();
                            } catch (e) {
                                console.error('Error destroying Lottie:', e);
                            }
                        }
                        child.remove();
                    }
                });

                // Determine media type and create appropriate element
                let mediaElement = null;
                if (lightboxMode === 'preset-preview') {
                    // Display both WebP and Lottie
                    const thumbnailUrl = item.thumbnail_url_4x || item.image_url;
                    const isLottie = thumbnailUrl && (thumbnailUrl.toLowerCase().endsWith('.json') || item.format === 'lottie' || item.format === 'lottie_avif');
                    
                    if (isLottie) {
                        const lottieLightboxId = `lottie-lightbox-${(item.preset_id || item.id || Date.now()).toString().replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const lottieDiv = document.createElement('div');
                        lottieDiv.id = lottieLightboxId;
                        lottieDiv.style.cssText = 'width: 100%; max-width: 100%; height: 60vh; max-height: 60vh; display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); border-radius: 8px;';
                        mediaElement = lottieDiv;
                        
                        // Insert first, then load animation
                        single.insertBefore(mediaElement, info);
                        
                        // Load Lottie animation after element is in DOM
                        const loadLottieAnimation = () => {
                            const container = document.getElementById(lottieLightboxId);
                            if (!container) {
                                console.warn('Lottie container not found:', lottieLightboxId);
                                return;
                            }
                            
                            if (typeof lottie === 'undefined') {
                                console.warn('Lottie library not loaded yet, retrying...');
                                setTimeout(loadLottieAnimation, 100);
                                return;
                            }
                            
                            if (!thumbnailUrl) {
                                console.warn('No thumbnail URL for Lottie');
                                return;
                            }
                            
                            try {
                                // Destroy any existing animation in this container
                                if (container.lottieInstance) {
                                    container.lottieInstance.destroy();
                                    container.lottieInstance = null;
                                }
                                
                                // Clear container content to prevent duplicates
                                container.innerHTML = '';
                                
                                const anim = lottie.loadAnimation({
                                    container: container,
                                    renderer: 'svg',
                                    loop: false,
                                    autoplay: true,
                                    path: thumbnailUrl
                                });

                                container.lottieInstance = anim;

                                // Handle errors
                                anim.addEventListener('data_failed', () => {
                                    console.error('Lottie data failed to load');
                                    container.innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); padding: 20px; text-align: center;">
                                        <div style="font-size: 48px; margin-bottom: 12px;">üì±</div>
                                        <div style="font-size: 14px; font-weight: 500;">Lottie Animation</div>
                                        <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Failed to load animation</div>
                                    </div>`;
                                });
                            } catch (e) {
                                console.error('Lottie lightbox load error:', e);
                                container.innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-secondary); padding: 20px; text-align: center;">
                                    <div style="font-size: 48px; margin-bottom: 12px;">üì±</div>
                                    <div style="font-size: 14px; font-weight: 500;">Lottie Animation</div>
                                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 8px;">Error: ${e.message}</div>
                                </div>`;
                            }
                        };
                        
                        setTimeout(loadLottieAnimation, 100);
                    } else if (thumbnailUrl) {
                        let displayImg = img;
                        if (!displayImg || !single.contains(displayImg)) {
                            displayImg = document.createElement('img');
                            displayImg.id = 'lightbox-image';
                        }
                        displayImg.src = thumbnailUrl;
                        displayImg.alt = item.label || 'Preset';
                        displayImg.style.cssText = 'max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; display: block;';
                        mediaElement = displayImg;
                        if (!single.contains(mediaElement)) {
                            single.insertBefore(mediaElement, info);
                        }
                    }
                } else {
                    // Regular preview mode
                    const previewUrl = item.image_url || item.result_url || '';
                    if (previewUrl) {
                        let displayImg = img;
                        if (!displayImg || !single.contains(displayImg)) {
                            displayImg = document.createElement('img');
                            displayImg.id = 'lightbox-image';
                        }
                        displayImg.src = previewUrl;
                        displayImg.alt = item.label || 'Preview';
                        displayImg.style.cssText = 'max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; display: block;';
                        mediaElement = displayImg;
                        if (!single.contains(mediaElement)) {
                            single.insertBefore(mediaElement, info);
                        }
                    }
                }

                // Update counter and info text
                if (counter) counter.textContent = `${item.label} (${lightboxCurrentIndex + 1} / ${lightboxItems.length})`;

                // Update info with full URL and prompt_json for preset-preview
                if (lightboxMode === 'preset-preview' && info) {
                    const thumbnailUrl = item.thumbnail_url_4x || item.image_url || '';
                    const presetId = item.preset_id || item.id;

                    // Ensure info is visible
                    info.style.display = 'block';
                    info.style.visibility = 'visible';
                    info.style.opacity = '1';
                    info.style.marginTop = '16px';

                    // Show URL first, then fetch and display prompt_json
                    info.innerHTML = `
                        <div style="color: #fff; font-size: 12px; word-break: break-all; font-family: 'Courier New', monospace; line-height: 1.4; margin-bottom: 12px;">${thumbnailUrl}</div>
                        <div id="lightbox-prompt-json" style="color: var(--text-muted); font-size: 11px;">Loading prompt...</div>
                    `;

                    // Fetch prompt_json from backend
                    if (presetId) {
                        fetchPresetPromptJson(presetId).then(promptData => {
                            const promptContainer = document.getElementById('lightbox-prompt-json');
                            if (promptContainer && promptData) {
                                const promptText = typeof promptData === 'string' ? promptData : JSON.stringify(promptData, null, 2);
                                promptContainer.innerHTML = `
                                    <div style="background: rgba(0,0,0,0.5); padding: 12px; border-radius: 8px; max-height: 200px; overflow-y: auto;">
                                        <div style="font-size: 11px; color: var(--accent); margin-bottom: 6px; font-weight: 600;">üìù Prompt JSON:</div>
                                        <pre style="margin: 0; white-space: pre-wrap; word-break: break-word; font-size: 10px; color: #ccc; line-height: 1.4;">${escapeHtml(promptText)}</pre>
                                    </div>
                                `;
                            } else if (promptContainer) {
                                promptContainer.innerHTML = `<div style="color: var(--text-muted); font-size: 11px;">No prompt data available</div>`;
                            }
                        }).catch(err => {
                            const promptContainer = document.getElementById('lightbox-prompt-json');
                            if (promptContainer) {
                                promptContainer.innerHTML = `<div style="color: var(--text-muted); font-size: 11px;">No prompt data</div>`;
                            }
                        });
                    }
                } else if (info) {
                    // For other modes, show counter in info
                    info.innerHTML = `<span id="lightbox-counter">${counter ? counter.textContent : ''}</span>`;
                }
            }

            // Show actions appropriately for each mode
            // Ensure actions div exists in lightbox-single
            const single = $('lightbox-single');
            if (single) {
                let actionsDiv = single.querySelector('.lightbox-actions');
                if (!actionsDiv) {
                    actionsDiv = $('lightbox-actions');
                    if (actionsDiv && actionsDiv.parentNode !== single) {
                        single.appendChild(actionsDiv);
                    }
                }
                
                if (actionsDiv) {
                    if (lightboxMode === 'preset-preview' || lightboxMode === 'selfie-preview') {
                        actionsDiv.style.display = 'flex';
                        actionsDiv.style.visibility = 'visible';
                        actionsDiv.style.opacity = '1';
                        actionsDiv.style.position = 'relative';
                        actionsDiv.style.marginTop = '20px';
                        actionsDiv.style.width = '100%';
                        actionsDiv.style.padding = '0 20px';
                    } else {
                        actionsDiv.style.display = 'none';
                    }
                }
            }
            
            // Also update the actions variable for backward compatibility
            if (actions) {
                if (lightboxMode === 'preset-preview' || lightboxMode === 'selfie-preview') {
                    actions.style.display = 'flex';
                    actions.style.visibility = 'visible';
                    actions.style.opacity = '1';
                    actions.style.position = 'relative';
                } else {
                    actions.style.display = 'none';
                }
            }
            
            // Update add to comparison button state
            if (addToComparisonBtn) {
                const isInComparison = comparisonItems.some(ci => ci.image_url === imageUrl);
                if (isInComparison) {
                    addToComparisonBtn.innerHTML = '<span>‚úì</span><span>ƒê√£ Th√™m</span>';
                    addToComparisonBtn.disabled = true;
                    addToComparisonBtn.style.opacity = '0.6';
                } else {
                    addToComparisonBtn.innerHTML = '<span>‚ûï</span><span>Th√™m v√†o So S√°nh</span>';
                    addToComparisonBtn.disabled = false;
                    addToComparisonBtn.style.opacity = '1';
                }
            }
            
            document.querySelector('.lightbox-prev').disabled = lightboxItems.length <= 1;
            document.querySelector('.lightbox-next').disabled = lightboxItems.length <= 1;
            lightbox.style.display = 'flex';

            // Scroll lightbox content to top
            if (single) single.scrollTop = 0;
            lightbox.scrollTop = 0;
        }
        
        function addToComparison() {
            if (lightboxCurrentIndex < 0 || lightboxCurrentIndex >= lightboxItems.length) return;
            const item = lightboxItems[lightboxCurrentIndex];
            const imageUrl = item.result_url || item.image_url || '';
            if (!imageUrl) {
                showStatusMessage('Kh√¥ng t√¨m th·∫•y URL h√¨nh ·∫£nh', 'error');
                return;
            }
            
            // Check if already in comparison
            if (comparisonItems.some(ci => ci.image_url === imageUrl)) {
                showStatusMessage('H√¨nh ·∫£nh ƒë√£ c√≥ trong danh s√°ch so s√°nh', 'info');
                return;
            }
            
            // Add to comparison (max 3 items)
            if (comparisonItems.length >= 3) {
                showStatusMessage('Ch·ªâ c√≥ th·ªÉ so s√°nh t·ªëi ƒëa 3 h√¨nh ·∫£nh. Vui l√≤ng x√≥a m·ªôt h√¨nh tr∆∞·ªõc.', 'error');
                return;
            }
            
            const comparisonItem = {
                image_url: imageUrl,
                label: item.label || `H√¨nh ${comparisonItems.length + 1}`,
                type: item.type || 'result',
                added_at: Date.now()
            };
            
            comparisonItems.push(comparisonItem);
            saveComparisonToStorage();
            updateLightbox();
            updateComparisonButton();
            showStatusMessage(`ƒê√£ th√™m v√†o so s√°nh (${comparisonItems.length}/3)`, 'success');
        }
        
        function removeFromComparison(index) {
            if (index >= 0 && index < comparisonItems.length) {
                comparisonItems.splice(index, 1);
                saveComparisonToStorage();
                updateComparisonButton();
                renderComparison();
                showStatusMessage('ƒê√£ x√≥a kh·ªèi so s√°nh', 'success');
            }
        }
        
        function clearComparison() {
            if (comparisonItems.length === 0) return;
            comparisonItems = [];
            saveComparisonToStorage();
            updateComparisonButton();
            renderComparison();
            showStatusMessage('ƒê√£ x√≥a t·∫•t c·∫£ h√¨nh ·∫£nh so s√°nh', 'success');
        }
        
        function renderComparison() {
            const comparisonContainer = $('lightbox-comparison');
            const comparisonGrid = $('comparison-grid');
            const singleView = $('lightbox-single');
            
            if (!comparisonContainer || !comparisonGrid) return;
            
            if (comparisonItems.length === 0) {
                comparisonContainer.style.display = 'none';
                if (singleView) singleView.style.display = 'flex';
                comparisonGrid.innerHTML = '';
                return;
            }
            
            // Show comparison view
            comparisonContainer.style.display = 'flex';
            if (singleView) singleView.style.display = 'none';
            
            // Update grid class based on count
            comparisonGrid.className = 'comparison-grid';
            if (comparisonItems.length === 2) {
                comparisonGrid.classList.add('compare-2');
            } else if (comparisonItems.length === 3) {
                comparisonGrid.classList.add('compare-3');
            }
            
            // Render items
            comparisonGrid.innerHTML = comparisonItems.map((item, index) => `
                <div class="comparison-item">
                    <button class="comparison-item-remove" onclick="removeFromComparison(${index})" title="X√≥a">√ó</button>
                    <img src="${item.image_url}" alt="${item.label}" loading="lazy" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'200\\' height=\\'200\\'%3E%3Crect fill=\\'%23ccc\\' width=\\'200\\' height=\\'200\\'/%3E%3Ctext fill=\\'%23999\\' font-family=\\'sans-serif\\' font-size=\\'14\\' x=\\'50%25\\' y=\\'50%25\\' text-anchor=\\'middle\\' dy=\\'.3em\\'%3EL·ªói t·∫£i h√¨nh%3C/text%3E%3C/svg%3E';">
                    <div class="comparison-item-label">${item.label}</div>
                </div>
            `).join('');
        }
        
        function switchToComparisonView() {
            const comparisonContainer = $('lightbox-comparison');
            const singleView = $('lightbox-single');
            if (comparisonContainer && singleView) {
                singleView.style.display = 'none';
                comparisonContainer.style.display = 'flex';
                renderComparison();
            }
        }
        
        function switchToSingleView() {
            const comparisonContainer = $('lightbox-comparison');
            const singleView = $('lightbox-single');
            if (comparisonContainer && singleView) {
                comparisonContainer.style.display = 'none';
                singleView.style.display = 'flex';
                updateLightbox();
            }
        }
        
        // Add button to show comparison view from lightbox
        function showComparisonView() {
            if (comparisonItems.length === 0) {
                showStatusMessage('Ch∆∞a c√≥ h√¨nh ·∫£nh n√†o trong danh s√°ch so s√°nh. Vui l√≤ng th√™m h√¨nh ·∫£nh t·ª´ lightbox tr∆∞·ªõc.', 'info');
                return;
            }
            $('lightbox').style.display = 'flex';
            switchToComparisonView();
            setupLightboxKeyboard();
        }
        
        window.addToComparison = addToComparison;
        window.removeFromComparison = removeFromComparison;
        window.clearComparison = clearComparison;
        window.switchToSingleView = switchToSingleView;
        window.showComparisonView = showComparisonView;

        window.openPreviewLightbox = openPreviewLightbox;

        async function uploadImageFromUrl(imageUrl, type) {
            if (!window.profileManager.currentProfile) {
                showStatusMessage('Vui l√≤ng ch·ªçn h·ªì s∆° tr∆∞·ªõc khi t·∫£i l√™n h√¨nh ·∫£nh.', 'error');
                return;
            }

            showLoading(`ƒêang t·∫£i ${type === 'preset' ? 'm·∫´u' : 'selfie'} t·ª´ URL...`);

            const config = galleries[type];
            const dropZone = $(type + '-drop-zone');
            dropZone?.classList.add('loading');

            try {
                const requestBody = {
                    image_url: imageUrl,
                    type: type,
                    profile_id: window.profileManager.currentProfile.id,
                    presetName: type === 'preset' ? `Preset ${Date.now()}` : undefined,
                    enableVertexPrompt: type === 'preset',
                };
                
                if (type === 'selfie') {
                    const actionSelect = document.getElementById('selfie-action-select');
                    const action = actionSelect?.value || 'faceswap';
                    requestBody.action = action;
                }

                const uploadUrl = `${WORKER_URL}/upload-url`;
                const startTime = Date.now();
                const uploadResponse = await fetch(uploadUrl, {
                    method: 'POST',
                    headers: buildHeaders({ 'Content-Type': 'application/json' }),
                    body: JSON.stringify(requestBody)
                });
                const data = await uploadResponse.json();
                const duration = Date.now() - startTime;

                logApiCall({ 
                    label: `T·∫£i L√™n ${config.logName}`, 
                    method: 'POST', 
                    url: '/upload-url',
                    fullUrl: uploadUrl,
                    status: uploadResponse.ok ? 'success' : 'error', 
                    payload: data, 
                    duration,
                    headers: { 'Content-Type': 'application/json' },
                    body: requestBody
                });

                if (!uploadResponse.ok || data.status !== 'success') {
                    const errorMsg = data.message || 'T·∫£i l√™n th·∫•t b·∫°i';
                    const error = new Error(errorMsg);
                    if (data.debug) {
                        error.debug = data.debug;
                    }
                    throw error;
                }

                // Handle new response format with data property
                const result = data.data?.results?.[0];
                if (!result || !result.id || !result.url) {
                    throw new Error('Upload response missing required data');
                }

                const newImage = { 
                    id: result.id, 
                    filename: result.filename, 
                    image_url: result.url, 
                    created_at: new Date().toISOString() 
                };
                config.state.items = [newImage, ...config.state.items.filter(e => e.id !== newImage.id)];
                config.state.page = 1;
                await loadGallery(type);
                setSelectedItem(type, newImage);
                showStatusMessage(`ƒê√£ ch·ªçn l√†m ${type === 'preset' ? 'm·∫´u' : 'selfie'} th√†nh c√¥ng!`, 'success');
                closeLightbox();
            } catch (error) {
                const errorMsg = error instanceof Error ? error.message : 'T·∫£i l√™n th·∫•t b·∫°i';
                const debugInfo = error?.debug;
                if (debugInfo) {
                    console.error('[Upload Error Debug]', debugInfo);
                }
                showStatusMessage(`T·∫£i l√™n th·∫•t b·∫°i: ${errorMsg}`, 'error');
            } finally {
                hideLoading();
                dropZone?.classList.remove('loading');
            }
        }

        async function selectAsPreset() {
            if (lightboxCurrentIndex < 0 || lightboxCurrentIndex >= lightboxItems.length) return;
            const item = lightboxItems[lightboxCurrentIndex];

            if (lightboxMode === 'preset-preview' && item.preset_id) {
                // For preset-preview mode, use the actual selected item from lightbox which has format info
                // Find the original preset item to get all fields
                const preset = galleries.preset.state.items.find(p => p.id === item.id);
                if (preset) {
                    // Create a selection item preserving format and using preset_id for API calls
                    const selectedPreset = {
                        ...preset,
                        id: preset.preset_id, // Use preset_id as id for API calls
                        preset_id: preset.preset_id,
                        format: preset.format || item.format, // Preserve format (webp, lottie, lottie_avif)
                        thumbnail_url_4x: preset.thumbnail_url_4x || item.thumbnail_url_4x,
                        image_url: preset.thumbnail_url_4x || preset.image_url || item.image_url
                    };
                    setSelectedItem('preset', selectedPreset, { showMessage: true });
                    showStatusMessage('ƒê√£ ch·ªçn l√†m m·∫´u th√†nh c√¥ng!', 'success');
                    closeLightbox();
                    return;
                }
            }

            // Fallback for other modes (results, etc.)
            const imageUrl = item.result_url || item.image_url || '';
            if (!imageUrl) {
                showStatusMessage('Kh√¥ng t√¨m th·∫•y URL h√¨nh ·∫£nh', 'error');
                return;
            }
            const tempPreset = {
                image_url: imageUrl,
                filename: imageUrl.split('/').pop() || 'result.jpg',
                created_at: new Date().toISOString()
            };
            setSelectedItem('preset', tempPreset, { showMessage: true });
            showStatusMessage('ƒê√£ ch·ªçn l√†m m·∫´u th√†nh c√¥ng!', 'success');
            closeLightbox();
        }

        async function selectAsSelfie() {
            if (lightboxCurrentIndex < 0 || lightboxCurrentIndex >= lightboxItems.length) return;
            const item = lightboxItems[lightboxCurrentIndex];
            const imageUrl = item.result_url || item.image_url || '';
            if (!imageUrl) {
                showStatusMessage('Kh√¥ng t√¨m th·∫•y URL h√¨nh ·∫£nh', 'error');
                return;
            }
            const tempSelfie = {
                image_url: imageUrl,
                filename: imageUrl.split('/').pop() || 'result.jpg',
                created_at: new Date().toISOString()
            };
            setSelectedItem('selfie', tempSelfie, { showMessage: true });
            showStatusMessage('ƒê√£ ch·ªçn l√†m selfie th√†nh c√¥ng!', 'success');
            closeLightbox();
        }

        window.selectAsPreset = selectAsPreset;
        window.selectAsSelfie = selectAsSelfie;

        // Main Tab Switching
        function switchMainTab(tab) {
            // Hide all main tabs
            document.querySelectorAll('.main-tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            document.querySelectorAll('.main-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            if (tab === 'faceswap') {
                $('faceswap-tab-content').classList.add('active');
                $('faceswap-tab-content').style.display = 'block';
                $('main-tab-faceswap').classList.add('active');
            } else if (tab === 'thumbnails') {
                $('thumbnails-tab-content').classList.add('active');
                $('thumbnails-tab-content').style.display = 'block';
                $('main-tab-thumbnails').classList.add('active');
                $('thumbnails-upload-section').style.display = 'block';
            }
        }


        async function loadThumbnails() {
            const startTime = Date.now();
            const url = `${WORKER_URL}/thumbnails`;
            try {
                const response = await fetch(url, { headers: buildHeaders() });
                const duration = Date.now() - startTime;
                const data = await response.json();
                
                logApiCall({
                    label: 'T·∫£i Danh S√°ch Thumbnails',
                    method: 'GET',
                    url: '/thumbnails',
                    fullUrl: url,
                    status: response.ok && data.status === 'success' ? 'success' : 'error',
                    payload: data,
                    duration
                });
                
                if (data.status === 'success' && data.data?.thumbnails) {
                    renderThumbnails(data.data.thumbnails);
                } else {
                    showStatusMessage('Kh√¥ng th·ªÉ t·∫£i danh s√°ch thumbnails', 'error');
                }
            } catch (error) {
                const duration = Date.now() - startTime;
                console.error('Failed to load thumbnails:', error);
                logApiCall({
                    label: 'T·∫£i Danh S√°ch Thumbnails',
                    method: 'GET',
                    url: '/thumbnails',
                    fullUrl: url,
                    status: 'error',
                    duration
                });
                showStatusMessage('Kh√¥ng th·ªÉ t·∫£i danh s√°ch thumbnails', 'error');
            }
        }

        async function downloadThumbnailsJson() {
            const startTime = Date.now();
            const url = 'https://api.d.shotpix.app/thumbnails';
            try {
                showStatusMessage('ƒêang t·∫£i d·ªØ li·ªáu thumbnails...', 'info');
                const response = await fetch(url, { headers: buildHeaders() });
                const duration = Date.now() - startTime;
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                logApiCall({
                    label: 'T·∫£i JSON Thumbnails',
                    method: 'GET',
                    url: '/thumbnails',
                    fullUrl: url,
                    status: response.ok && data.status === 'success' ? 'success' : 'error',
                    payload: data,
                    duration
                });
                
                // Create JSON blob and download
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const downloadUrl = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = `thumbnails_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(downloadUrl);
                
                showStatusMessage('ƒê√£ t·∫£i JSON thumbnails th√†nh c√¥ng!', 'success');
            } catch (error) {
                const duration = Date.now() - startTime;
                console.error('Failed to download thumbnails JSON:', error);
                logApiCall({
                    label: 'T·∫£i JSON Thumbnails',
                    method: 'GET',
                    url: '/thumbnails',
                    fullUrl: url,
                    status: 'error',
                    duration
                });
                showStatusMessage(`Kh√¥ng th·ªÉ t·∫£i JSON: ${error.message}`, 'error');
            }
        }

        function renderThumbnails(thumbnails) {
            const container = $('thumbnail-list');
            if (!container) return;

            if (thumbnails.length === 0) {
                container.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: var(--text-muted); padding: 40px;">No 4x thumbnails available. Upload thumbnail folders to see them here.</p>';
                return;
            }

            // Sort thumbnails by preset_id using natural alphanumeric order (f1_1, f1_2, m1_1, m1_2, etc.)
            const sortedThumbnails = [...thumbnails].sort((a, b) => {
                return a.preset_id.localeCompare(b.preset_id, undefined, { numeric: true, sensitivity: 'base' });
            });

            // Display thumbnail images in a grid (WebP only)
            container.innerHTML = sortedThumbnails.map((thumbnail, index) => {
                const presetId = thumbnail.preset_id;
                const thumbnailUrl = thumbnail.thumbnail_url_4x;

                if (!thumbnailUrl) {
                    return `<div class="thumbnail-item" style="border: 1px solid var(--border); border-radius: 8px; padding: 12px; background: var(--bg-primary); text-align: center;">
                        <div style="color: var(--text-muted); font-size: 12px;">No 4x thumbnail available</div>
                        <div style="color: var(--text-secondary); font-size: 10px; margin-top: 4px;">${presetId}</div>
                    </div>`;
                }

                const mediaElement = `<img src="${thumbnailUrl}" alt="Thumbnail ${presetId}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 4px;" loading="lazy">`;

                return `<div class="thumbnail-item" onclick="selectThumbnailAsPreset('${presetId}')" style="border: 1px solid var(--border); border-radius: 8px; padding: 12px; background: var(--bg-primary); cursor: pointer; transition: all 0.2s; position: relative;" onmouseover="this.style.borderColor='var(--accent)'" onmouseout="this.style.borderColor='var(--border)'">
                    ${mediaElement}
                    <div class="thumbnail-item-info" style="margin-top: 8px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 11px; font-weight: 500;">${presetId}</div>
                        <div style="color: var(--text-muted); font-size: 10px;">4x Thumbnail</div>
                    </div>
                </div>`;
            }).join('');

            // Apply grid layout
            container.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 12px;
                margin-top: 12px;
            `;
        }

        async function selectThumbnail(presetId) {
            if (!presetId) {
                showStatusMessage('Thumbnail ch∆∞a ƒë∆∞·ª£c li√™n k·∫øt v·ªõi preset', 'error');
                return;
            }
            // Load preset and set as selected
            try {
                const response = await fetch(`${WORKER_URL}/presets/${presetId}`, { headers: buildHeaders() });
                const data = await response.json();
                if (data && data.image_url) {
                    const tempPreset = {
                        id: presetId,
                        image_url: data.image_url,
                        filename: data.filename,
                        created_at: new Date().toISOString()
                    };
                    setSelectedItem('preset', tempPreset, { showMessage: true });
                    showStatusMessage('ƒê√£ ch·ªçn preset t·ª´ thumbnail', 'success');
                    switchMainTab('faceswap');
                }
            } catch (error) {
                showStatusMessage('Kh√¥ng th·ªÉ t·∫£i preset', 'error');
            }
        }

        async function selectThumbnailAsPreset(presetId) {
            if (!presetId) {
                showStatusMessage('Preset ID kh√¥ng h·ª£p l·ªá', 'error');
                return;
            }

            // Create a virtual preset object using the thumbnail name as preset_id
            // The thumbnail 4x image serves as the preset image
            try {
                // Load thumbnail data to get the 4x image URL
                const response = await fetch(`${WORKER_URL}/thumbnails`, { headers: buildHeaders() });
                const data = await response.json();

                if (data.status === 'success' && data.data?.thumbnails) {
                    const thumbnail = data.data.thumbnails.find((t) => t.preset_id === presetId);
                    if (thumbnail && thumbnail.thumbnail_url_4x) {
                        const tempPreset = {
                            id: presetId,
                            image_url: thumbnail.thumbnail_url_4x,
                            filename: `thumbnail_${presetId}`,
                            created_at: new Date().toISOString(),
                            from_thumbnail: true // Mark that this preset comes from a thumbnail
                        };
                        setSelectedItem('preset', tempPreset, { showMessage: true });
                        showStatusMessage(`ƒê√£ ch·ªçn thumbnail ${presetId} l√†m preset`, 'success');
                        switchMainTab('faceswap');
                    } else {
                        showStatusMessage('Kh√¥ng t√¨m th·∫•y thumbnail 4x', 'error');
                    }
                } else {
                    showStatusMessage('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu thumbnail', 'error');
                }
            } catch (error) {
                showStatusMessage('Kh√¥ng th·ªÉ t·∫£i thumbnail', 'error');
            }
        }

        async function getPresetFromThumbnail(thumbnailId) {
            if (!thumbnailId) {
                showStatusMessage('Thumbnail ID kh√¥ng h·ª£p l·ªá', 'error');
                return;
            }
            try {
                const startTime = Date.now();
                const url = `${WORKER_URL}/thumbnails/${thumbnailId}/preset`;
                const response = await fetch(url);
                const duration = Date.now() - startTime;
                const data = await response.json();
                logApiCall({
                    label: 'L·∫•y Preset t·ª´ Thumbnail',
                    method: 'GET',
                    url: `/thumbnails/${thumbnailId}/preset`,
                    fullUrl: url,
                    status: response.ok ? 'success' : 'error',
                    payload: data,
                    duration
                });
                if (!response.ok) throw new Error(data.message || `HTTP ${response.status}`);
                if (data.data?.preset_id) {
                    await selectThumbnail(data.data.preset_id);
                } else {
                    showStatusMessage('Kh√¥ng t√¨m th·∫•y preset t·ª´ thumbnail', 'error');
                }
            } catch (error) {
                showStatusMessage(`L·ªói khi l·∫•y preset t·ª´ thumbnail: ${error.message}`, 'error');
            }
        }

        async function loadConfig() {
            showLoading('ƒêang t·∫£i c·∫•u h√¨nh...');
            try {
                const startTime = Date.now();
                const url = `${WORKER_URL}/config`;
                const response = await fetch(url);
                const duration = Date.now() - startTime;
                const data = await response.json();
                logApiCall({
                    label: 'L·∫•y C·∫•u H√¨nh',
                    method: 'GET',
                    url: '/config',
                    fullUrl: url,
                    status: response.ok ? 'success' : 'error',
                    payload: data,
                    duration
                });
                if (!response.ok) throw new Error(data.message || `HTTP ${response.status}`);
                const configInfo = JSON.stringify(data.data, null, 2);
                alert(`C·∫•u h√¨nh Backend:\n\n${configInfo}\n\nXem chi ti·∫øt trong Nh·∫≠t K√Ω API`);
                showStatusMessage('ƒê√£ t·∫£i c·∫•u h√¨nh th√†nh c√¥ng', 'success');
            } catch (error) {
                showStatusMessage(`L·ªói khi t·∫£i c·∫•u h√¨nh: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        async function listAllProfiles() {
            showLoading('ƒêang t·∫£i danh s√°ch profiles...');
            try {
                const startTime = Date.now();
                const url = `${WORKER_URL}/profiles`;
                const response = await fetch(url);
                const duration = Date.now() - startTime;
                const data = await response.json();
                logApiCall({
                    label: 'Li·ªát K√™ Profiles',
                    method: 'GET',
                    url: '/profiles',
                    fullUrl: url,
                    status: response.ok ? 'success' : 'error',
                    payload: data,
                    duration
                });
                if (!response.ok) throw new Error(data.message || `HTTP ${response.status}`);
                const profiles = data.data?.profiles || [];
                const profilesInfo = profiles.length > 0
                    ? profiles.map(p => `ID: ${p.id}\nT√™n: ${p.name || 'N/A'}\nEmail: ${p.email || 'N/A'}\nDevice: ${p.device_id || 'N/A'}\n---`).join('\n')
                    : 'Ch∆∞a c√≥ profiles n√†o';
                alert(`T·ªïng s·ªë Profiles: ${profiles.length}\n\n${profilesInfo}\n\nXem chi ti·∫øt trong Nh·∫≠t K√Ω API`);
                showStatusMessage(`ƒê√£ t·∫£i ${profiles.length} profiles`, 'success');
            } catch (error) {
                showStatusMessage(`L·ªói khi t·∫£i danh s√°ch profiles: ${error.message}`, 'error');
            } finally {
                hideLoading();
            }
        }

        // Enhanced retry function for preset uploads - NEVER LOSE DATA
        // Defined at module level so it can be used by multiple functions
        const fetchWithRetry = async (url, options, maxRetries = 8, retryDelay = 2000) => {
            const errors = [];
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    // Add timeout to fetch (60s for large uploads)
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => {
                        controller.abort();
                    }, 60000); // 60s timeout for preset uploads

                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    // If successful, return immediately
                    if (response.ok) {
                        return response;
                    }

                    // If server error (5xx), retry unless last attempt
                    if (response.status >= 500 && response.status < 600) {
                        if (attempt < maxRetries - 1) {
                            const errorText = await response.text().catch(() => response.statusText);
                            errors.push(`${attempt + 1}: HTTP ${response.status}: ${errorText.substring(0, 100)}`);
                            // Continue to retry logic below
                        } else {
                            // Last attempt - return response anyway so caller can handle it
                            return response;
                        }
                    } else {
                        // Client error (4xx) - don't retry, throw immediately
                        const errorText = await response.text().catch(() => response.statusText);
                        throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                    }

                } catch (error) {
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    const isLastAttempt = attempt === maxRetries - 1;

                    console.error(`[Preset Upload] Attempt ${attempt + 1}/${maxRetries} failed:`, errorMsg);
                    errors.push(`${attempt + 1}: ${errorMsg}`);

                    // Check if this is a retryable error
                    const isRetryable = error.name === 'AbortError' || // Timeout
                                      error.message.includes('fetch') || // Network error
                                      error.message.includes('network') || // Network error
                                      error.message.includes('Failed to fetch') || // Network error
                                      error.message.includes('TypeError') || // Network error
                                      error.message.includes('500') || // Server error
                                      error.message.includes('502') || // Bad gateway
                                      error.message.includes('503') || // Service unavailable
                                      error.message.includes('504') || // Gateway timeout
                                      (!error.message.includes('400') && // Don't retry client errors
                                       !error.message.includes('401') && // Don't retry auth errors
                                       !error.message.includes('403') && // Don't retry forbidden errors
                                       !error.message.includes('404'));  // Don't retry not found

                    if (!isRetryable || isLastAttempt) {
                        console.error(`[Preset Upload] Final failure after ${maxRetries} attempts`);
                        console.error(`[Preset Upload] All errors:`, errors);
                        throw new Error(`Upload failed after ${maxRetries} attempts. Errors: ${errors.join(' | ')}`);
                    }

                    // Exponential backoff with jitter: 2s, 4s, 8s, 16s, 32s, 64s, 128s
                    const baseDelay = retryDelay * Math.pow(2, attempt);
                    const jitter = Math.random() * 0.3 * baseDelay; // Add up to 30% jitter
                    const delay = Math.min(baseDelay + jitter, 120000); // Cap at 2 minutes

                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        };

        async function handleThumbnailZipSelect(event) {
            const allFiles = Array.from(event.target.files || []);
            if (allFiles.length === 0) return;

            // Separate zip files and regular files
            const zipFiles = [];
            const regularFiles = [];
            
            for (const file of allFiles) {
                if (file.name.toLowerCase().endsWith('.zip')) {
                    zipFiles.push(file);
                } else {
                    regularFiles.push(file);
                }
            }

            // Use the same client-side extraction and upload logic as drag & drop
            await processThumbnailFiles(zipFiles, regularFiles);

            // Reset input
            event.target.value = '';
        }

        async function processThumbnailFiles(zipFiles, regularFiles) {
            const progressContainer = $('thumbnail-upload-progress');
            const progressFill = $('thumbnail-progress-fill');
            const statusText = $('thumbnail-upload-status');
            
            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            statusText.textContent = 'ƒêang x·ª≠ l√Ω file...';

            // Check if filter mode is enabled for thumbnails
            const filterModeCheckbox = document.getElementById('thumbnail-filter-mode');
            const isFilterMode = filterModeCheckbox && filterModeCheckbox.checked;
            
            // Get custom prompt if user has customized it
            const { defaultPrompt, filterPrompt } = loadCustomPrompts();
            const currentPrompt = isFilterMode ? filterPrompt : defaultPrompt;
            const originalPrompt = isFilterMode ? DEFAULT_PROMPTS.FILTER : DEFAULT_PROMPTS.DEFAULT;
            const customPromptText = currentPrompt !== originalPrompt ? currentPrompt : null;
            
            // Get thumbnail formats (can be both webp and json)
            const formatWebp = document.getElementById('thumbnail-format-webp');
            const formatJson = document.getElementById('thumbnail-format-json');
            const thumbnailFormats = [];
            if (formatWebp && formatWebp.checked) thumbnailFormats.push('webp');
            if (formatJson && formatJson.checked) thumbnailFormats.push('json');
            if (thumbnailFormats.length === 0) thumbnailFormats.push('webp'); // Default to webp if none selected
            
            // Extract all files from zip files client-side
            const allFiles = [];
            
            // Extract files from zip archives
            if (zipFiles.length > 0) {
                statusText.textContent = `ƒêang gi·∫£i n√©n ${zipFiles.length} file zip...`;
                progressFill.style.width = '5%';
                
                for (let i = 0; i < zipFiles.length; i++) {
                    const zipFile = zipFiles[i];
                    try {
                        statusText.textContent = `ƒêang gi·∫£i n√©n zip ${i + 1}/${zipFiles.length}...`;
                        const zip = await JSZip.loadAsync(zipFile);
                        
                        // Extract all files from zip (await all promises)
                        const zipEntries = [];
                        zip.forEach((relativePath, zipEntry) => {
                            if (!zipEntry.dir) {
                                zipEntries.push({ relativePath, zipEntry });
                            }
                        });
                        
                        // Filter for files in "preset" folder only
                        const presetFiles = zipEntries.filter(({ relativePath }) => {
                            const normalizedPath = relativePath.replace(/\\/g, '/').toLowerCase();
                            return normalizedPath.includes('preset/') || normalizedPath.startsWith('preset/');
                        });
                        
                        if (presetFiles.length === 0) {
                            console.warn(`No preset files found in zip: ${zipFile.name}`);
                            showStatusMessage(`Kh√¥ng t√¨m th·∫•y file preset trong zip: ${zipFile.name}`, 'warning');
                            continue;
                        }
                        
                        // Process all entries in parallel for faster extraction
                        const extractedFiles = await Promise.all(
                            presetFiles.map(async ({ relativePath, zipEntry }) => {
                                try {
                                    const fileData = await zipEntry.async('blob');
                                    if (!fileData || fileData.size === 0) {
                                        return null;
                                    }
                                    const file = new File([fileData], zipEntry.name, { type: 'image/png' });
                                    return {
                                        file: file,
                                        path: relativePath
                                    };
                                } catch (extractError) {
                                    return null;
                                }
                            })
                        );

                        // Filter out null entries (failed extractions)
                        const validFiles = extractedFiles.filter(f => f !== null);
                        allFiles.push(...validFiles);
                    } catch (zipError) {
                        showStatusMessage(`L·ªói gi·∫£i n√©n ${zipFile.name}: ${zipError.message}`, 'error');
                    }
                }
            }
            
            // Add regular files (non-zip) to the upload queue
            if (regularFiles.length > 0) {
                regularFiles.forEach(file => {
                    const resolution = '4x';
                    // Use first format for path, backend will generate all formats
                    const primaryFormat = thumbnailFormats[0] || 'webp';
                    const formatPrefix = primaryFormat === 'json' ? 'lottie' : 'webp';
                    const path = `${formatPrefix}_${resolution}/${file.name}`;
                    allFiles.push({
                        file: file,
                        path: path
                    });
                });
            }
            
            const totalFiles = allFiles.length;
            if (totalFiles === 0) {
                statusText.textContent = 'Kh√¥ng c√≥ file preset n√†o ƒë·ªÉ t·∫£i l√™n';
                progressContainer.style.display = 'none';
                return;
            }

            statusText.textContent = `ƒêang x·ª≠ l√Ω ${totalFiles} file preset (gi·ªõi h·∫°n 10 file c√πng l√∫c)...`;
            progressFill.style.width = '10%';

            // Process files with controlled concurrency (10 at a time)
            const results = [];
            let successful = 0;
            let failed = 0;
            let presetsProcessed = 0;
            let thumbnailsProcessed = 0;
            let presetsWithPrompts = 0;

            const uploadUrl = `${WORKER_URL}/process-thumbnail-file`;
            const startTime = Date.now();

            // Concurrency limiter function
            const processWithConcurrency = async (items, concurrency = 10) => {
                const results = [];
                for (let i = 0; i < items.length; i += concurrency) {
                    const batch = items.slice(i, i + concurrency);
                    const batchPromises = batch.map(async ({ file, path }) => {
                        // Validate file exists and has size
                        if (!file || file.size === 0) {
                            return {
                                success: false,
                                filename: file?.name || path || 'unknown',
                                error: 'File is empty or missing'
                            };
                        }

                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('path', path);
                        // Send all selected formats as comma-separated list
                        formData.append('thumbnail_formats', thumbnailFormats.join(','));
                        if (isFilterMode) {
                            formData.append('is_filter_mode', 'true');
                        }
                        if (customPromptText) {
                            formData.append('custom_prompt_text', customPromptText);
                        }

                        try {
                            const response = await fetchWithRetry(uploadUrl, {
                                method: 'POST',
                                headers: buildHeaders(),
                                body: formData
                            }, 10); // Use 10 retries for individual files too

                            if (!response.ok) {
                                const errorText = await response.text().catch(() => response.statusText);
                                throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
                            }

                            const data = await response.json();

                            if (data.status === 'success' && data.data.success) {
                                return {
                                    success: true,
                                    data: data.data
                                };
                            } else {
                                return {
                                    success: false,
                                    filename: file.name,
                                    error: data.message || data.data?.error || 'Unknown error'
                                };
                            }
                        } catch (fileError) {
                            let errorMessage = 'Failed to fetch';
                            if (fileError.name === 'AbortError') {
                                errorMessage = 'Request timeout (30s)';
                            } else if (fileError.message) {
                                errorMessage = fileError.message;
                            } else if (fileError instanceof TypeError) {
                                errorMessage = 'Network error - check CORS and connection';
                            }
                            
                            return {
                                success: false,
                                filename: file.name,
                                error: errorMessage
                            };
                        }
                    });
                    
                    const batchResults = await Promise.all(batchPromises);
                    results.push(...batchResults);
                    
                    // Update progress
                    const processed = i + batch.length;
                    const progressPercent = 10 + (processed / totalFiles) * 80;
                    progressFill.style.width = `${Math.min(progressPercent, 90)}%`;
                    statusText.textContent = `ƒêang x·ª≠ l√Ω ${processed}/${totalFiles} file...`;
                    
                    // Small delay between batches to prevent overwhelming server
                    if (i + concurrency < items.length) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                return results;
            };

            try {
                // Process files with concurrency limit
                let uploadResults = await processWithConcurrency(allFiles, 10);
                
                // Retry failed files until all succeed or max retries reached
                const maxRetryRounds = 5;
                let retryRound = 0;
                let failedFiles = [];
                
                while (retryRound < maxRetryRounds) {
                    // Collect failed files
                    failedFiles = [];
                    uploadResults.forEach((result, index) => {
                        if (!result.success) {
                            failedFiles.push({
                                file: allFiles[index].file,
                                path: allFiles[index].path,
                                filename: result.filename,
                                error: result.error
                            });
                        }
                    });
                    
                    if (failedFiles.length === 0) {
                        break; // All files succeeded
                    }
                    
                    retryRound++;
                    console.log(`[Retry Round ${retryRound}/${maxRetryRounds}] Retrying ${failedFiles.length} failed files...`);
                    statusText.textContent = `ƒêang th·ª≠ l·∫°i ${failedFiles.length} file th·∫•t b·∫°i (l·∫ßn ${retryRound}/${maxRetryRounds})...`;
                    
                    // Wait before retry with exponential backoff
                    const retryDelay = Math.min(2000 * Math.pow(2, retryRound - 1), 10000);
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                    
                    // Retry failed files
                    const retryItems = failedFiles.map(f => ({ file: f.file, path: f.path }));
                    const retryResults = await processWithConcurrency(retryItems, 10);
                    
                    // Update results with retry outcomes
                    let retryIndex = 0;
                    uploadResults = uploadResults.map(result => {
                        if (!result.success && retryIndex < retryResults.length) {
                            const retryResult = retryResults[retryIndex++];
                            return retryResult;
                        }
                        return result;
                    });
                }

                // Process final results
                uploadResults.forEach(result => {
                    if (result.success) {
                        successful++;
                        results.push(result.data);

                        if (result.data.type === 'preset') {
                            presetsProcessed++;
                            if (result.data.hasPrompt) {
                                presetsWithPrompts++;
                            }
                        } else if (result.data.type === 'thumbnail') {
                            thumbnailsProcessed++;
                        }
                    } else {
                        failed++;
                        results.push({
                            filename: result.filename,
                            success: false,
                            error: result.error
                        });
                        console.warn(`Failed to process ${result.filename}:`, result.error);
                    }
                });
                
                const duration = Date.now() - startTime;
                progressFill.style.width = '90%';
                statusText.textContent = `Ho√†n th√†nh x·ª≠ l√Ω song song, ƒëang t·ªïng h·ª£p k·∫øt qu·∫£...`;
                await new Promise(resolve => setTimeout(resolve, 200));
                progressFill.style.width = '100%';
                
                // Log API call summary (without full results array)
                logApiCall({
                    label: `T·∫£i L√™n Presets & Thumbnails (${totalFiles} files)`,
                    method: 'POST',
                    url: '/process-thumbnail-file',
                    fullUrl: uploadUrl,
                    status: failed === 0 ? 'success' : 'error',
                    payload: {
                        total: totalFiles,
                        successful: successful,
                        failed: failed,
                        presets_processed: presetsProcessed,
                        presets_with_prompts: presetsWithPrompts,
                        thumbnails_processed: thumbnailsProcessed,
                        retry_rounds: retryRound
                    },
                    duration
                });
                
                // Show detailed progress information
                let statusParts = [];
                statusParts.push(`‚úì ${successful}/${totalFiles} files`);
                if (presetsProcessed > 0) {
                    statusParts.push(`${presetsProcessed} presets (${presetsWithPrompts} with AI prompts)`);
                }
                if (thumbnailsProcessed > 0) {
                    statusParts.push(`${thumbnailsProcessed} thumbnails`);
                }
                if (retryRound > 0) {
                    statusParts.push(`${retryRound} retry rounds`);
                }
                
                statusText.textContent = statusParts.join(' | ');
                
                if (failed > 0) {
                    const finalFailedFiles = results.filter(r => !r.success).map(r => r.filename);
                    console.warn(`Failed files (${failed}):`, finalFailedFiles);
                    showStatusMessage(`${failed} file th·∫•t b·∫°i sau ${retryRound} l·∫ßn th·ª≠ l·∫°i. Ki·ªÉm tra console ƒë·ªÉ xem chi ti·∫øt.`, 'error');
                } else {
                    showStatusMessage('T·∫£i l√™n th√†nh c√¥ng 100%!', 'success');
                }
                
                // Reset inputs
                const zipInput = $('thumbnail-zip-input');
                if (zipInput) zipInput.value = '';
                
                // Reload thumbnails after upload
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    loadThumbnails();
                }, 1000);
            } catch (error) {
                const duration = Date.now() - startTime;
                logApiCall({
                    label: `T·∫£i L√™n Presets & Thumbnails (${totalFiles} files)`,
                    method: 'POST',
                    url: '/process-thumbnail-file',
                    fullUrl: uploadUrl,
                    status: 'error',
                    payload: { error: error.message },
                    duration
                });
                progressFill.style.width = '100%';
                progressFill.style.background = 'var(--danger)';
                statusText.textContent = `L·ªói: ${error.message}`;
                showStatusMessage(`T·∫£i l√™n th·∫•t b·∫°i: ${error.message}`, 'error');
            }
        }

        function setupThumbnailDragDrop() {
            const dropZone = $('thumbnail-drop-zone');
            if (!dropZone) return;

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });

            // Visual feedback
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = 'var(--accent)';
                    dropZone.style.background = 'var(--bg-tertiary)';
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = 'var(--border)';
                    dropZone.style.background = 'var(--bg-primary)';
                }, false);
            });

            // Handle drop
            dropZone.addEventListener('drop', async (e) => {
                const items = Array.from(e.dataTransfer.items || []);
                const zipFiles = [];
                const regularFiles = [];

                for (const item of items) {
                    if (item.kind === 'file') {
                        const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                        const file = item.getAsFile();

                        if (file) {
                            if (file.name.toLowerCase().endsWith('.zip')) {
                                zipFiles.push(file);
                            } else if (entry && entry.isDirectory) {
                                // Directory not supported - show message
                                showStatusMessage('Th∆∞ m·ª•c kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Vui l√≤ng n√©n th√†nh file zip.', 'info');
                            } else {
                                regularFiles.push(file);
                            }
                        }
                    }
                }

                // Process files
                if (zipFiles.length > 0 || regularFiles.length > 0) {
                    await processThumbnailFiles(zipFiles, regularFiles);
                }
            }, false);
        }

        window.switchMainTab = switchMainTab;
        window.handleThumbnailZipSelect = handleThumbnailZipSelect;
        window.selectThumbnail = selectThumbnail;

        // UI Helpers
        function showLoading(text = 'ƒêang t·∫£i d·ªØ li·ªáu') {
            const overlay = $('loading-overlay');
            if (overlay) {
                overlay.style.display = 'flex';
                const textEl = overlay.querySelector('.loading-text');
                if (textEl) textEl.textContent = text;
                startLoadingTimer();
            }
        }

        function hideLoading() {
            const overlay = $('loading-overlay');
            if (overlay) overlay.style.display = 'none';
            stopLoadingTimer();
        }

        function showStatusMessage(message, type = 'info') {
            document.querySelectorAll('.status-message').forEach(m => m.remove());
            const div = document.createElement('div');
            div.className = `status-message status-${type}`;
            div.innerHTML = `${message}<button class="status-close" onclick="this.parentElement.remove()">√ó</button>`;
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 4000);
        }


        // Initialize
        async function init() {
            showLoading('ƒêang t·∫£i d·ªØ li·ªáu');
            try {
                await loadGallery('preset');
                // Selfie and results are already loaded by initializeProfile(), no need to load again
                updateResultsCount();
                updateGenerateButton();
                updateImageOperationButtons();
            } finally {
                hideLoading();
            }
        }

        // Prevent zoom gestures on mobile and auto-reset zoom
        function preventZoom() {
            let lastTouchEnd = 0;
            let lastTouchStart = 0;
            let touchStartTime = 0;
            let touchCount = 0;
            
            // Monitor and reset zoom level
            function resetZoom() {
                const viewport = document.querySelector('meta[name="viewport"]');
                if (viewport) {
                    viewport.setAttribute('content', 'width=375, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover');
                }
                
                // Force reset using document.body.style.zoom (if supported)
                if (document.body.style.zoom !== undefined) {
                    document.body.style.zoom = '1';
                }
                
                // Force reset using transform scale
                const currentScale = window.visualViewport ? window.visualViewport.scale : 1;
                if (currentScale !== 1) {
                    document.documentElement.style.transform = 'scale(1)';
                    document.documentElement.style.transformOrigin = 'top left';
                }
            }
            
            // Continuously monitor and reset zoom
            setInterval(resetZoom, 100);
            
            // Reset on any touch event
            document.addEventListener('touchstart', function(event) {
                touchCount = event.touches.length;
                touchStartTime = Date.now();
                
                if (event.touches.length > 1) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
                
                // Prevent if too quick (double tap)
                const timeSinceLastTouch = Date.now() - lastTouchStart;
                if (timeSinceLastTouch < 300 && timeSinceLastTouch > 0) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
                lastTouchStart = Date.now();
            }, { passive: false, capture: true });
            
            // Prevent double-tap zoom
            document.addEventListener('touchend', function(event) {
                const now = Date.now();
                const timeSinceStart = now - touchStartTime;
                
                if (timeSinceStart < 300 && touchCount === 1) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
                
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
                lastTouchEnd = now;
                touchCount = 0;
            }, { passive: false, capture: true });
            
            // Prevent gesture zoom (iOS Safari)
            document.addEventListener('gesturestart', function(event) {
                event.preventDefault();
                event.stopPropagation();
                resetZoom();
                return false;
            }, { passive: false, capture: true });
            
            document.addEventListener('gesturechange', function(event) {
                event.preventDefault();
                event.stopPropagation();
                resetZoom();
                return false;
            }, { passive: false, capture: true });
            
            document.addEventListener('gestureend', function(event) {
                event.preventDefault();
                event.stopPropagation();
                resetZoom();
                return false;
            }, { passive: false, capture: true });
            
            // Prevent pinch zoom during move
            document.addEventListener('touchmove', function(event) {
                if (event.touches.length > 1) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
            }, { passive: false, capture: true });
            
            // Prevent wheel zoom
            document.addEventListener('wheel', function(event) {
                if (event.ctrlKey || event.metaKey) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
            }, { passive: false, capture: true });
            
            // Prevent keyboard zoom (Ctrl/Cmd + Plus/Minus)
            document.addEventListener('keydown', function(event) {
                if ((event.ctrlKey || event.metaKey) && (event.key === '+' || event.key === '-' || event.key === '=' || event.keyCode === 187 || event.keyCode === 189)) {
                    event.preventDefault();
                    event.stopPropagation();
                    resetZoom();
                    return false;
                }
            }, { passive: false, capture: true });
            
            // Reset on orientation change
            window.addEventListener('orientationchange', function() {
                setTimeout(resetZoom, 100);
            });
            
            // Reset on resize
            let resizeTimer;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(resetZoom, 100);
            });
            
            // Initial reset
            resetZoom();
        }
        
        // Call preventZoom immediately, not just on DOMContentLoaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', preventZoom);
        } else {
            preventZoom();
        }

        // Startup
        document.addEventListener('DOMContentLoaded', async () => {
            initAccessGate();
            setupDragDrop('preset');
            setupDragDrop('selfie');

            $('profile-id-input')?.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); switchProfile(); } });
            
            // Add event listener for additional-prompt input to update button state (used as custom prompt for background)
            const additionalPromptInput = $('additional-prompt');
            if (additionalPromptInput) {
                additionalPromptInput.addEventListener('input', () => {
                    updateGenerateButton();
                });
                additionalPromptInput.addEventListener('keyup', () => {
                    updateGenerateButton();
                });
            }

            // Load saved aspect ratio from localStorage (default to 'original' for non-faceswap endpoints)
            // For image operations (enhance, beauty, etc.), always default to 'original' to preserve input aspect ratio
            const savedRatio = localStorage.getItem('faceswap:aspectRatio') || 'original';
            const aspectRatioSelect = document.getElementById('aspect-ratio');
            if (aspectRatioSelect) {
                // Ensure 'original' is the default for image operations
                if (!savedRatio || savedRatio === '3:4') {
                    aspectRatioSelect.value = 'original';
                    localStorage.setItem('faceswap:aspectRatio', 'original');
                } else {
                    aspectRatioSelect.value = savedRatio;
                }
                console.log('[Init] Set aspect ratio select to:', aspectRatioSelect.value, 'Saved value:', savedRatio);
                aspectRatioSelect.addEventListener('change', (e) => {
                    const newValue = e.target.value;
                    localStorage.setItem('faceswap:aspectRatio', newValue);
                    console.log('[Init] Aspect ratio changed to:', newValue);
                });
            } else {
                console.error('[Init] Aspect ratio select element not found during initialization!');
            }

            // Load saved provider from localStorage
            const savedProvider = localStorage.getItem('faceswap:provider') || '';
            const providerSelect = document.getElementById('image-provider');
            if (providerSelect) {
                providerSelect.value = savedProvider;
                console.log('[Init] Set provider select to:', providerSelect.value);
                providerSelect.addEventListener('change', (e) => {
                    const newValue = e.target.value;
                    localStorage.setItem('faceswap:provider', newValue);
                    console.log('[Init] Provider changed to:', newValue);
                });
            } else {
                console.error('[Init] Provider select element not found during initialization!');
            }

            // Load saved model from localStorage
            let savedModel = localStorage.getItem('faceswap:model') || '2.5';
            // Migrate legacy '3' value to '3p' for backward compatibility
            if (savedModel === '3') {
                savedModel = '3p';
                localStorage.setItem('faceswap:model', savedModel);
            }
            const modelSelect = document.getElementById('gemini-model');
            if (modelSelect) {
                modelSelect.value = savedModel;
                console.log('[Init] Set model select to:', savedModel, 'Current value:', modelSelect.value);
                modelSelect.addEventListener('change', (e) => {
                    const newValue = e.target.value;
                    localStorage.setItem('faceswap:model', newValue);
                    console.log('[Init] Model changed to:', newValue);
                });
            } else {
                console.error('[Init] Model select element not found during initialization!');
            }


            // Initialize category selection from localStorage before loading galleries
            const savedCategory = localStorage.getItem('preset:selectedCategory');
            if (savedCategory) {
                galleries.preset.state.selectedCategory = savedCategory;
            }
            const savedParentCategory = localStorage.getItem('preset:selectedParentCategory');
            if (savedParentCategory) {
                galleries.preset.state.selectedParentCategory = savedParentCategory;
            } else {
                galleries.preset.state.selectedParentCategory = 'All';
            }
            
            // Initialize profile FIRST, then load galleries
            await window.profileManager.initializeProfile();
            await init();
            
            
            // Setup thumbnail drag and drop
            setupThumbnailDragDrop();
        });
    </script>
</body>
</html>
